[{"title":"Golang攻略-其他语言迁移到Go","path":"/2026/01/06/golang-start/","content":"点开我就当至少你会Python C++ C# Java任意一种了，所以示例代码为主，没有的话不要继续看因为会看不懂。所以安装我就不多说了，Windows去这里下安装包，linux用包管理器。看完本文你将速通Go的基本语法，变量声明，数组，循环，Switch，函数，结构体，Map，错误处理，接口鸭子类型，指针 先跑起来创建个新文件夹，然后用vscode打开，搭一下脚手架 go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,directgo install golang.org/x/tools/gopls@latestgo mod init go-starter GO111MODULE？GO111MODULE=on是开启 Go 的现代包管理模式，并且把这个设置全局保存 在 Go 1.11 版本（也就是变量名里 111 的由来）之前，Go 的包管理非常反人类，被称为 GOPATH 模式。 旧模式 (GOPATH)： 所有的代码项目，必须强制放在一个固定的文件夹里（比如 D:\\GoWorks\\src）。这就像 C# 强制要求把所有 Visual Studio 的项目都放在C:\\Windows\\Microsoft.NET\\Framework 下面一样荒谬。没有版本控制的概念。go get 下来的库，作者升级了，项目可能就炸了。 新模式 (Go Modules)： 也就是 GO111MODULE=on。代码可以放在电脑的任何地方（桌面、D盘、E盘随便）。它使用 go.mod 文件来记录依赖版本（类似于 Python 的 requirements.txt 或 C# 的 .csprojpackages.config）。 项目? go install和go get？如果不创建一个项目的话，vscode右下角会一直爆警告，而且代码补全可能会失效，因为它不知道包依赖关系。刚刚装的gopls就是go语言的IntelliSense引擎。项目也是使用go get安装第三方库要用的，类似于nodejs的package.json go install会不会就是类似于python的pip install？其实不然 go install是用来装 工具（可执行程序 .exe）的，go get是用来装库（依赖包） 的。 Python的pip是两个都可以装，比如我可以pip install jupyter，然后直接在cmd里使用jupyter notebook启动网页端程序，也可以使用pip install requests装包然后在别的.py里使用 go把它拆开来了 比如刚刚装的gopls，实际就是：先下载gopls的源代码，把它编译成exe后丢进GOPATH里给vscode用 现在的 go get 已经禁止安装可执行文件了，必须用 go install。 命令 作用 产物 类比 Python go install 安装二进制工具 生成 .exe 放到 bin 目录 pip install httpie (为了用命令) go get 安装开发依赖库 更新 go.mod，下载源码供 import pip install requests (为了写代码) 你好世界编程惯例写个hello world能提高运气 package mainimport fmtfunc main() fmt.Println(hellooooo worlddddd) 使用go build *.go生成二进制文件或者go run *.go直接运行 PS D:\\go-start go build .\\hello.goPS D:\\go-start .\\hello.exeHello, World!PS D:\\go-start go run .\\hello.go Hello, World! package main 是干嘛的？ Go 的编译器（go build 或 go run）需要知道代码的入口在哪里。 一个可执行程序必须有一个名为 main 的包，并且该包里必须包含一个 main() 函数。 如果没有 package main，Go 会把它当成一个库，就不会去找入口函数，也就跑不起来。 别的如果有编程基础都能看懂 变量声明标准格式var hajimi stringvar wochao int = 42 变量会被初始化为该类型的零值，也可以在后面加上赋值 短变量声明func main() hajimi := wochao := 42 fmt.Println(hajimi, World!) _ = wochao 使用:=关键字，不需要写类型，go会直接根据内容推导出变量数据类型 但是注意，这样声明变量只能在函数内部。而且golang有个特性，函数内部声明了的变量就必须要用，不然编译会报错。所以最后把wochao赋值给了下划线 _ 占位符 匿名变量// 假设函数返回 (int, error)count, _ := getCount() // 忽略掉第二个返回的 error 如果调用一个返回多个值的函数，但只想用其中一个，可以用下划线 _ 占位。 一次声明多个变量func main() var x, y, z = true, two, 3 // 不同类型 var a, b, c string // 相同类型 name, age := 关小雨, 18 // 短变量声明 fmt.Println(name, age) fmt.Println(x, y, z) c = a + b + c 可以通过标准格式和短变量声明一次声明多个变量，变量可以是不同的数据类型 这样运行的输出是: 关小雨 18true two 3 批量声明如果有很多很多变量，可以用括号包起来，通常用于全局变量 var ( name string = 关小雨 age int = 18 sex string = 女 height float32)func main() fmt.Println(name) 数组Arrayarray，顾名思义，数组，和C一样，长度固定的数组 最经典长度是类型的一部分，且长度固定。下面是最标准的写法，声明时指定长度和类型 // 声明一个长度为 5 的 int 数组，默认全是 0var nums [5]int// 声明并直接初始化var arr = [3]int10, 20, 30// 短变量声明names := [2]string张三, 李四 懒得数了我懒得数长度了: q := [...]int1, 2, 3, 4, 5 这样编译器会去数个数，长度还是5 指定赋值可以只给数组里某几个位置赋值，其他位置会自动补零值。 // 索引 1 是 10，索引 3 是 30，长度为 5a := [5]int1: 10, 3: 30// 结果: [0, 10, 0, 30, 0] 多维数组用法和别的编程语言一样 // 2行3列matrix := [2][3]int 1, 2, 3, 4, 5, 6,fmt.Println(matrix[1][2]) // 输出 6 SliceOK上面关于数组的内容统统没有用，因为我们99%的时间都在用切片，而不是数组。切片是对数组的封装，它的长度可以根据需要动态增长。说人话就是动态数组 创建动态数组和数组一样，就是不需要指定中括号里的数字 s1 := []int1, 2, 3 s2 := make([]int, 5, 10) 也可以使用make()并指定预留的长度和初始的数据 上面第二行的意思就是s2有5个0在里面，但是给他预留了10个int的空间 但是切片是动态长度，预留空间何意味？ 如果不预留，超出长度的时候，Go 发现没地方了 - 开辟新内存 - 搬家 - 再append - 又没地方了 - 再次开辟更大内存 - 再次搬家 频繁搬家（内存分配和数据复制）非常消耗性能，前 10 次添加数据，Go 发现还有空位，直接放进去就行，不需要搬家。等到第 11 个数据来了，包间满了，Go 才会进行一次大规模搬家（通常会把容量翻倍，比如换个 20 人的大包间）。 设定 cap (容量) 是为了 减少底层数组扩容的次数，提高程序运行速度。虽然不设也能跑，但设了跑得更快。 往里面加东西通过append可以往动态数组里塞数据 s := []int1, 2s = append(s, 3) // 添加一个：[1 2 3]s = append(s, 4, 5, 6) // 添加多个：[1 2 3 4 5 6]// 甚至可以把另一个切片直接倒进去（注意后面有三个点）another := []int7, 8s = append(s, another...) // [1 2 3 4 5 6 7 8] 动态数组的切片和python的list切片类似，可以从一个现成的数组或动态数组中，截取出一部分。 arr := [5]int0, 1, 2, 3, 4s := arr[1:4] // 截取索引 1 到 3 (左闭右开)// 结果: [1, 2, 3]// 快捷写法s = arr[:3] // 从开头到索引 2s = arr[2:] // 从索引 2 到结尾 （所以我要叫它动态数组，要不然我就要说是切片的切片） 数组和动态数组的传递数组是值传递，会把值复制一份用于传递。 func change(a [3]int) a[0] = 999 // 这里改的是副本func main() nums := [3]int1, 2, 3 change(nums) fmt.Println(nums[0]) // 依然是 1 而切片是“引用”传递，实际上是传了一个包含指针的结构体。 func update(s []int) s[0] = 888func main() nums := []int1, 2, 3 update(nums) fmt.Println(nums[0]) // 输出 888 严格来说，Go 只有值传递。切片本质上是一个只有 3 个字段的结构体 Struct { ptr, len, cap }。当传递切片时，是把这个小结构体复制（值传递）了一份。但因为里面那个 ptr 指针指向了同一个底层数组，所以修改数据会同步。 循环最经典for i := 0; i 5; i++ fmt.Println(i) 源·whilego里面没有while，但是可以直接把for循环当while用。 也是因为go没有while关键字，所以while在go里甚至可以定义成变量 while := 0for while 5 fmt.Println(while) while++ 如果什么都不加，直接一个for起手那就是死循环了 次跑循环类似于python中的for i in range(5)，不过格式是这么写的 for i := range 5 fmt.Println(i) 精准定位类似于python的 for i, char in enumerate(你好Go): print(f位置 i 的字符是 char) 在go里面不需要借助额外的函数，直接这么写: for i, char := range 你好Go fmt.Printf(位置 %d 的字符是 %c , i, char) 如果我要遍历数组或者动态数组 for i, v := range nums 就当go会展开为 for i := 0; i len(nums); i++ v := nums[i] go的for循环语法糖: 写法 含义 for i := range s 只要索引 for _, v := range s 只要值 for range s 什么都不要，只循环次数 打个坐标如果有嵌套循环，想在内层循环直接跳出最外层，可以使用标签。 OuterLoop: for i := 0; i 5; i++ for j := 0; j 5; j++ if i*j 10 break OuterLoop // 直接跳出到最外层标签处 不要把break OuterLoop理解为goto OuterLoop，标签只是为了指明作用范围。当执行 break OuterLoop 时，编译器会找到 OuterLoop 标记的那层循环，并立即终止这整层循环。 如果是想跳过当前剩余逻辑，直接进入外层循环的下一次迭代，那就和其他语言一样使用continue Switch最经典func main() x := 2 switch x case 1: fmt.Println(x 等于 1) case 2: fmt.Println(x 等于 2) case 3: fmt.Println(x 等于 3) default: fmt.Println(x 不等于 1, 2 或 3) 一case多值我也不知道是不是go的特性 switch x case 1: fmt.Println(x 等于 1) case 2, 3, 4, 5, 6, 7, 8, 9: fmt.Println(x 大于 2 小于 10) default: fmt.Println(x 大于 10) 也可以这么写，如果switch后面不加变量名，就类似于if-else switch case x == 1: fmt.Println(x 等于 1) case x 2 x 10: fmt.Println(x 大于 2 小于 10) default: fmt.Println(x 大于 10) 大炮穿箱可以使用fallthrough来执行完当前 case 后继续执行下一个 case func main() x := 9 switch case x == 1: fmt.Println(x 等于 1) case x 2 x 10: fmt.Println(x 大于 2 小于 10) fallthrough default: fmt.Println(x 大于 10) 因为在case x 2 x 10:增加了fallthrough，所以下一个default case也被执行了 x 大于 2 小于 10x 大于 10 顺手的事可以在 switch 后面定义一个只在 switch 块内有效的变量。 func main() switch grade := B; grade case A: fmt.Println(A) case B: fmt.Println(我超 bin) default: fmt.Println(铸币吧) 函数最经典Go 的参数名在前，类型在后。 // 单参数，单返回值func square(n int) int return n * n// 相同类型的参数可以简写func add(a, b, c int) int return a + b + c// 多返回值 上面说过的func divide(a, b float64) (float64, error) if b == 0 return 0, errors.New(除数不能为0) return a / b, nil 味大无需多盐，有其他编程基础的都能看懂 指定返回在函数头定义返回变量名，函数体里赋值，最后只用写个return就能返回指定变量 func getRect(width, height int) (area, perimeter int) area = width * height perimeter = (width + height) * 2 return // 自动返回 area 和 perimeter 变长参数用 ... 表示可以传入任意数量的参数。 func sum(nums ...int) int total := 0 for _, n := range nums total += n return total 匿名函数没有名字的函数，通常用于临时逻辑。 func main() // 定义并立即执行 func(msg string) fmt.Println(msg) (Hello Go) 方法函数Go没有类，但可以给结构体绑定函数。这个马上讲结构体会再提这里不展开 type User struct Name string// (u User) 是接收者，表示这个函数属于 Userfunc (u User) Greet() fmt.Println(Hello, I am, u.Name) 结构体Go 没有 class（类），结构体就是 Go 里的“类”。 它不仅能存数据，还能绑定方法，甚至通过“组合”来实现类似继承的功能。 创建结构体使用 type 和 struct 关键字。用法和别的编程语言类似 type user struct name string\tsex string\tage intfunc main() //键值对初始化\tu1 := username: 关小雨, sex: female, age: 18\tfmt.Println(u1.name, u1.sex, u1.age)\t//按顺序初始化\tu2 := user云悠悠, female, 20\tfmt.Println(u2.name, u2.sex, u2.age)\t//什么都不填，全是零值\tu3 := user\tfmt.Println(u3.name, u3.sex, u3.age)\t//部分初始化，其他为零值\tu4 := username: 晴雅\tfmt.Println(u4.name, u4.sex, u4.age) 上面的输出就是 关小雨 female 18云悠悠 female 20 0晴雅 0 给结构体加函数就是上文提到的方法函数(Method)， Go 的方法定义和 C++ 不一样，它不写在结构体里面，而是写在外面，通过接收者 (Receiver)绑定到结构体上。 格式是这样: func (接收者变量 接收者类型) 方法名(参数) 返回值 ... 接收者有两种，值接收者或者指针接收者 (u user)：值接收者。相当于把结构体复制了一份传进来。改了它，原来的数据不会变。 (u *user)：指针接收者，传的是内存地址。改了他原来的数据就变了 还是那个user结构体，给他分别用值接收者和指针接收者加上两个函数 type user struct name string\tsex string\tage intfunc (u user) sayHello() fmt.Printf(你好，我是 %s , u.name)\t//尝试增加年龄\tu.age++\tfmt.Printf(在 sayHello 方法中，%s 的年龄是 %d , u.name, u.age)func (u *user) haveBirthday() u.age++func main() u1 := username: 关小雨, sex: female, age: 18\tu1.sayHello()\tfmt.Printf(%s 现在是 %d 岁 , u1.name, u1.age)\tu1.haveBirthday()\tfmt.Printf(%s 现在是 %d 岁 , u1.name, u1.age) 这样的输出结果是 你好，我是 关小雨在 sayHello 方法中，关小雨 的年龄是 19关小雨 现在是 18 岁关小雨 现在是 19 岁 嵌套组合既然没有继承，怎么复用代码？go提倡 “组合优于继承”。可以把一个结构体塞进另一个结构体里，这叫匿名嵌入。 type Animal struct Type stringfunc (a *Animal) Eat() fmt.Println(a.Type, 正在吃东西...)type Dog struct Animal // 并没有给字段起名字，直接写类型 - 这就是嵌入\tName stringfunc main() d := Dog Name: 旺财, Animal: AnimalType: 犬科, d.Eat() //Dog 也拥有了 Animal 的方法\tfmt.Println(d.Name, d.Type, d.Animal.Type) //可以直接访问，也可以通过嵌入类型访问 这样的输出结果是 犬科 正在吃东西...旺财 犬科 犬科 Dog 并没有成为 Animal 的子类，它只是包含了一个 Animal。 Mapgo语言的 map 就是哈希表，它是无序（每次遍历 Map 的顺序可能都不一样，Go 故意引入了随机性）的键值对集合。说人话就是python的dict和java的hashmap 声明与初始化声明 map 后，如果不用 make 初始化，它就是 nil，直接赋值会报错 panic 可以这样用make创建:make(map[Key类型]Value类型) age := make(map[string]int) age[关小雨] = 18 也可以通过字面量初始化，声明的时候赋值 age := map[string]int 关小雨: 18, 云悠悠: 20, // 最后一个逗号不能少 增删改查无需多盐，字面意思 m := make(map[string]string)// 增 改m[name] = 关小雨 // 新增m[name] = 云悠悠 // 修改，覆盖旧值// 查name := m[name]fmt.Println(name) // 云悠悠// 删delete(m, name) // 删除键 name// 如果删除一个不存在的键，Go 不会报错，什么都不发生 查不到啊这是 map 独特的特性。去拿一个不存在的 Key 时，不会报错，而是返回该类型的零值（比如 int 返回 0，string 返回 “”）。但这有个坑：不知道返回的 0 是因为它真的存了 0，还是因为根本没这个 Key。 解决方案：双返回值判断 func main() ages := make(map[string]int)\tage, ok := ages[关小雨]\tif ok fmt.Println(关小雨的分数是, age) else fmt.Println(查无此人) ok 是一个布尔值，true 表示存在，false 表示不存在。 Key能用的类型？只要能用 == 比较的类型，都能当 Key。 可以：bool, int, float, string, 指针, channel, 接口 不可以：动态数组, map, 函数 错误处理众所不周知，Go 语言没有 try-catch-finally 这种异常处理机制。 Go 的设计哲学是：错误也是一种值。它不希望把错误“抛出”到一个不可预知的地方，而是希望原地处理或者显式地传递它。 在继续错误处理之前，得知道这么一个go的关键字:nil nilnil 是 go 语言中某些特定类型的默认零值。可以把它类比为其他语言中的 null 或 None在 Go 中，这些类型的“空值”都是 nil：接口，指针 ，切片，映射，通道和函数。 但是go的基本类型不能是nil而是默认值： int 的零值是 0。 string 的零值是 （空字符串），不是 nil。 bool 的零值是 false。 这样就杜绝了像 C 语言中“这到底是数字 0 还是空指针”的二义性。 多返回值让函数在返回结果的同时，多返回一个 error 类型的值。 func doSomething() (int, error) chushi := true if chushi return 0, fmt.Errorf(出事了) else return 100, nil func main() res, err := doSomething() if err != nil // 原地处理错误 fmt.Println(报错:, err) return // 没报错才继续 fmt.Println(结果是:, res) 如果返回的error不是nil，那就出大事了 添加信息给底层的错误加点描述，再往上传，可以使用 %w。 func openConfig(filepath string) error _, err := os.Open(filepath) if err != nil // 使用 %w 包装原始错误 return fmt.Errorf(读取配置文件失败: %w, err) return nilfunc main() err := openConfig(config.yaml) if err != nil fmt.Println(出事了, err) 这样的输出就是 出事了 读取配置文件失败: open config.yaml: The system cannot find the file specified. 扣1复活Go 虽然没有 try-catch，但有 panic-recover 机制。这不是用来处理普通业务错误的，而是用来处理毁灭性错误（比如数组越界、空指针、数据库连接不上）。 func protect() defer func() fmt.Println(1111 复活成功并且捕捉到了崩溃:, recover()) () fmt.Println(准备开始搞破坏...) panic(坠机了) // 相当于 throwfunc main() protect() fmt.Println(程序继续运行...) defer这个关键字的意思是:它后面的函数在当前函数退出前的最后一刻，一定会执行。哪怕函数崩溃了，defer 里的内容也会被执行。 recover是用来”复活”程序的，只能写在defer里。用于获取到出的问题。recover 不仅能捕获手动写的 panic，还能捕获go运行时触发的“运行时错误”（Runtime Error）。 panic是用来手动触发一个错误的函数 这样的执行结果是: 准备开始搞破坏...1111 复活成功并且捕捉到了崩溃: 坠机了程序继续运行... 自定义error在 Go 中，任何实现了Error() string方法的类型都可以是一个错误。 type MyError struct Code int Message stringfunc (e *MyError) Error() string return fmt.Sprintf(错误码:%d, 消息:%s, e.Code, e.Message)func getAPI() error return MyErrorCode: 404, Message: 找不到了func main() err := getAPI() if err != nil fmt.Println(API调用失败:, err) 这个后文讲鸭子类型的时候会再翻出来解析 接口鸭子类型如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。 在 Go 里：只要一个类型实现了接口要求的所有方法，它就自动属于这个接口，不需要显式写 implements。 创建和使用先这样定义一个鸭叫接口 type Quack interface Quack() 但是不止鸭子能叫，人也能学鸭子叫。所以再定义人和鸭的结构体并实现Quack函数 type duck struct name string func (d duck) Quack() fmt.Println(d.name, 嘎嘎嘎) type person struct name string func (p person) Quack() fmt.Println(p.name, 学鸭子叫：嘎嘎嘎) 现在再来创建一个用于调用鸭叫接口的函数 func makeQuack(q Quack) q.Quack() person和duck都可以调用这个鸭叫接口函数 func main() d1 := duckname: 唐老鸭\tp1 := personname: 张三\tmakeQuack(d1)\tmakeQuack(p1) 输出是: 唐老鸭 嘎嘎嘎张三 学鸭子叫：嘎嘎嘎 空接口go中有一个特殊的接口:any，没有定义任何方法。既然没有任何要求，那就意味着：任何类型都实现了空接口。它可以装万物 type duck struct name string func main() var i any = 10 // 可以装 int\tfmt.Println(i)\ti = Hello // 可以装 string\tfmt.Println(i)\ti = duckname: Daffy // 可以装 duck 结构体\tfmt.Println(i.(duck).name) 这样的输出结果是: HelloDaffy 指针Go 的指针在语法上和 CC++ 非常像，但在逻辑上被“阉割”，为了安全和简单。 没有指针运算，没有复杂的内存管理，没有 - 箭头符号 使用指针和CC++一样。 (取地址)，获取变量的内存地址。* (解引用)，获取指针指向的值，或者定义指针类型。 func main() a := 10\tptr := a\tfmt.Println(ptr) // 0xc00000a0c8 内存地址\tfmt.Println(*ptr) // 10\t*ptr = 20\tfmt.Println(a) // 20 结构体指针的“语法糖”在 C++ 中，访问指针对象的字段要用箭头 p-age。在 Go 中，统一都用点 .。编译器会分辨是值还是指针。 type User struct Name string\tAge intfunc main() u := UserName: 关小雨, Age: 18\tptr := u\tptr.Name = 云悠悠 // 编译器自动识别 ptr 是指针，自动解引用\tfmt.Println(u.Name) 使用场景需要修改外部变量go函数默认是值传递（拷贝）。如果想在函数里修改外面的变量，必须传指针。 // 接收指针类型 *intfunc change(n *int) *n = 999func main() x := 10\tchange(x) // 传地址进去\tfmt.Println(x) // 999 避免大对象拷贝如果结构体很大（比如有 100 个字段），传值会发生一次巨大的内存拷贝。传指针只需要拷贝 8 个字节（64位系统），速度快很多。 总而言之 特性 C++ 指针 Go 指针 定义符号 * * 取址符号 成员访问 - (指针), . (对象) 统一用 . 指针运算 支持 (p++, p+1) 不支持 (报错) 野指针释放 需要手动 delete GC 自动回收，不用管 安全性 危险 (易越界内存泄漏) 相对安全 public?private?虽然我觉得这么做有点逆天但是，在 Go 中，首字母大写类似于Public，首字母小写类似于Private。不仅仅是变量名，还包括函数名、结构体名、结构体内部的字段名 为什么说类似，因为这个public和private都指的是能不能跨包访问 package mainimport (\tencoding/json\tfmt)type User struct name string age int func main() u := Username: 关小雨, age: 18\tdata, _ := json.Marshal(u)\tfmt.Println(string(data)) 这样运行，输出是空的，json.Marshal 是 json 包里的函数，它是“外人”，它看不到 User 里没导出的 name 和 age。 但是如果把结构体变量名首字母都改成大写，就正常了 package mainimport (\tencoding/json\tfmt)type User struct Name string\tAge intfunc main() u := UserName: 关小雨, Age: 18\tdata, _ := json.Marshal(u)\tfmt.Println(string(data)) 运行正常输出 Name:关小雨,Age:18 Congratulations恭喜，看完本文你已经了解了其他编程语言到golang的迁移 你可能在找 Goroutine Channel？Go 最强的并发特性留到下一篇专门讲。","tags":["golang","notebook"]},{"title":"Mysql攻略-进阶功能到更多","path":"/2026/01/04/mysql-higher/","content":"看完本文你将速通：窗口函数，处理 JSON 数据，CTE (通用表表达式)，触发器，存储过程等等高级功能。看完你就是Mysql高手 还是用上一篇文章里的py生成的数据 窗口函数窗口函数是Mysql8.0+的功能，它允许用户在不改变查询结果集行数的情况下，对每一行执行聚合计算或其他复杂的计算。 窗口函数不会改变查询结果集的行数，而是为每一行添加一个额外的列，这个列包含了窗口函数的计算结果。这使得窗口函数非常适合于需要在保持原始数据的同时进行聚合或其他复杂计算的场景。 使用窗口函数的SQL语法是 窗口函数 OVER ( [PARTITION BY 字段1, 字段2...] -- 【分组】：按什么归类（比如按用户、按班级） [ORDER BY 字段3 ASC/DESC] -- 【排序】：组内按什么顺序算（比如按金额、按成绩） [ROWS/RANGE ...] -- 【范围】：(进阶) 滑动窗口范围，通常用默认值) 窗口函数(参数)：指定要使用的函数及其参数。函数可以是聚合函数，也可以是专门为窗口函数设计的函数。 PARTITION BY 分区表达式（可选）：将结果集分成多个分区，窗口函数会在每个分区内独立执行。分区表达式可以是一个或多个列名，用于确定如何将结果集分成不同的分区。 ORDER BY 排序表达式 ASC | DESC（可选）：指定窗口内行的排序顺序。排序表达式可以是一个或多个列名，用于确定窗口内行的排序方式。 ROWS/Range 行范围（可选）：定义窗口的行范围。行范围可以是固定的行数（如ROWS BETWEEN 2 PRECEDING AND CURRENT ROW），也可以是相对于当前行的动态范围（如ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW，表示从窗口开始到当前行的所有行）。 常用的窗口函数: 分类 函数名 作用 例子 序号排名 ROW_NUMBER() 唯一序号 (1, 2, 3, 4) 给每个订单编个号，即使金额一样也不能重复 RANK() 跳跃排名 (1, 2, 2, 4) 并列第一，下一个就是第三名，相同的值会留下空位 DENSE_RANK() 紧凑排名 (1, 2, 2, 3) 并列第一，下一个是第二名。不会为相同的值留下空位 (适合发奖状) 错位偏移 LAG(col, n) 往前看 n 行 这一单比上一单多花多少钱？ LEAD(col, n) 往后看 n 行 这一单比下一单少花多少钱？ 分布切片 NTILE(n) 切成 n 份 把用户分成“高中低”消费三档 聚合窗口 SUM(), AVG() 累计组内统计 算出用户的累计消费流水 上手使用窗口函数还记得那个富豪榜吗 SELECT u.username, SUM(o.total_amount) as moneyFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.usernameORDER BY money DESC; 在这里只是使用了ORDER BY来让他使用购买额来排序，但是并没有一个单独的列告诉我这是排名第几？ +----------+----------+| username | money |+----------+----------+| 刘林 | 69024.00 || 王萍 | 57733.00 || 余建华 | 57539.00 |省略若干行..| 齐琳 | 10975.00 |+----------+----------+19 rows in set (0.0014 sec) 如果想给他单独添加一行告诉我排名，就是用窗口函数的RANK select u.username, SUM(o.total_amount) as money, RANK() OVER(ORDER BY SUM(o.total_amount) DESC) as ranklistFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.usernameORDER BY money DESC; RANK()指我要对后面的东西来排名 OVER()表示指定的窗口-窗口是SUM(o.total_amout)的DESC排名 所以，连起来的意思就是，对SUM(o.total_amout)的DESC的这一列进行RANK()排名 然后将这一个排名列命名为ranklist。执行后的效果是这样的: +----------+----------+----------+| username | money | ranklist |+----------+----------+----------+| 刘林 | 69024.00 | 1 || 王萍 | 57733.00 | 2 || 余建华 | 57539.00 | 3 |.....省略若干行.....| 潘岩 | 14220.00 | 17 || 李阳 | 11863.00 | 18 || 齐琳 | 10975.00 | 19 |+----------+----------+----------+19 rows in set (0.0021 sec) 如果我非要把这个列命名为rank如果把这一列命名成rank的话就会报错 select u.username, SUM(o.total_amount) as money, RANK() OVER(ORDER BY SUM(o.total_amount) DESC) as rankFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.usernameORDER BY mone 报错内容为: ERROR: 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near rank 这不是Mysql版本的问题，而是这个rank和窗口函数RANK()冲突了 这就像在 Python 里写 print = 1 或者在 Java 里写 int class = 5 一样，不能用系统自带的命令名来给变量起名。 如果不想换名字非要用rank?必须用 反引号把它包起来 SELECT u.username, SUM(o.total_amount) as money, -- 加了反引号 `rank`，告诉 MySQL 这是别名，不是关键字 RANK() OVER(ORDER BY SUM(o.total_amount) DESC) as `rank`FROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.usernameORDER BY money DESC; 这样执行的效果就是 +----------+----------+----------+| username | money | rank |+----------+----------+----------+| 刘林 | 69024.00 | 1 || 王萍 | 57733.00 | 2 || 余建华 | 57539.00 | 3 |.....省略若干行.....| 潘岩 | 14220.00 | 17 || 李阳 | 11863.00 | 18 || 齐琳 | 10975.00 | 19 |+----------+----------+----------+19 rows in set (0.0021 sec) 窗口函数和聚合函数的区别窗口函数是单独新增一个列，并且给每一行放上窗口函数输出的值，在不压行的情况下算统计。 而聚合函数顾名思义是把多行压成一行 对比点 聚合函数 窗口函数 行数 会变少 不变 是否保留明细 不保留 保留 是否用 GROUP BY 必须常用 不需要 适合干嘛 汇总报表 排名、占比、累计 心智模型 压成一坨 每行旁边算一遍 PARTITION BY（分区）的使用假如我要获取到东莞市的前三排名用户消费金额 SELECT u.city, u.username, IFNULL(SUM(o.total_amount),0) as money, RANK() OVER(ORDER BY SUM(o.total_amount) DESC) as ranklistFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idWHERE u.city = 东莞市GROUP BY u.city, u.usernameLIMIT 3; OK成功获取到结果 +--------+----------+----------+----------+| city | username | money | ranklist |+--------+----------+----------+----------+| 东莞市 | 王淑华 | 15365.00 | 1 || 东莞市 | 戴秀云 | 9909.00 | 2 || 东莞市 | 刘鹏 | 9589.00 | 3 |+--------+----------+----------+----------+3 rows in set (0.0192 sec) 假如我要获取全国前三消费城市 SELECT u.city, IFNULL(SUM(o.total_amount),0) as money, RANK() OVER(ORDER BY SUM(o.total_amount) DESC) as ranklistFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.city, u.usernameLIMIT 3; 这样也能获取到富豪城市前三 +--------+----------+----------+| city | money | ranklist |+--------+----------+----------+| 淮安市 | 33505.00 | 1 || 丽华市 | 31875.00 | 2 || 秀芳县 | 30721.00 | 3 |+--------+----------+----------+3 rows in set (0.1092 sec) 那假如我要获取到每个城市的消费前三呢，这时候可以使用PARTITION BY SELECT * FROM(SELECT u.city, u.username, IFNULL(SUM(o.total_amount),0) as money, RANK() OVER( PARTITION BY u.city ORDER BY SUM(o.total_amount) DESC ) as ranklistFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.city, u.username)AS tWHERE t.ranklist = 3 AND t.money 0; 这样执行结果就是想要的了 +------------+----------+----------+----------+| city | username | money | ranklist |+------------+----------+----------+----------+| 上海县 | 张斌 | 19107.00 | 1 || 上海县 | 林帆 | 14341.00 | 2 || 上海县 | 张雪 | 6129.00 | 3 || 东莞市 | 王淑华 | 15365.00 | 1 || 东莞市 | 戴秀云 | 9909.00 | 2 || 东莞市 | 刘鹏 | 9589.00 | 3 |...省略若干行...+------------+----------+----------+----------+690 rows in set (0.1214 sec) 这个SQL有点复杂先看里面那个 首先去了用户表的名字，和城市，并且是使用左连接把这两列和订单表里的金额列通过userid连了起来，并且使用姓名和城市进行分组。 这时候在内存是这样的: 姓名 城市 购买金额 布莱恩 圆蛤镇 5000 布莱恩 圆蛤镇 1000 斯图威 圆蛤镇 500 梅格 圆蛤镇 NULL(梅格只注册没有下过单) 耄耋 白手套 120 耄爸 白手套 10 耄妈 白手套 10000 然后再通过SUM聚合函数把购买金额给聚合了起来 姓名 城市 购买金额 布莱恩 圆蛤镇 6000 斯图威 圆蛤镇 500 梅格 圆蛤镇 NULL 耄耋 白手套 120 耄爸 白手套 10 耄妈 白手套 10000 然后进入窗口函数，首先对城市进行分区。圆蛤镇和白手套单独使用SUM(o.total_amount)内部进行RANK。 如果不加分区，就会让耄妈排名第一，耄爸排名第六。而设计的目标是要取每个城市的前三。所以这样，通过按照城市分区后，再分区内部单独RANK就获取到了每个城市的排名。但是显然不可能每个城市只有3个人。所以把里面这个SQL输出作为表再次运行一次子查询，要求t.ranklist = 3 AND t.money 0这样就成功取到所有城市的消费前三了。 ROWSRange如果说 PARTITION BY 是把蛋糕切成大块，ORDER BY 是给切好的蛋糕排队，那么 ROWS RANGE 就是“定义手里的放大镜到底要看几行”（Window Frame）。 它们定义了：在当前这一行进行计算时，要回头看几行？往后看几行？ 窗口函数 OVER ( PARTITION BY ... ORDER BY ... [ROWS|RANGE] BETWEEN 开始位置 AND 结束位置) 常用的位置关键字： CURRENT ROW：当前这一行。 n PRECEDING：往前 n 行。 n FOLLOWING：往后 n 行。 UNBOUNDED PRECEDING：最前面（起点）。 UNBOUNDED FOLLOWING：最后面（终点）。 rows的使用rows使用行，往前一行或者往后一行 比如要计算值为3的移动平均线，就是获取前天，昨天，今天的数值加起来除以3 SELECT total_amount, AVG(total_amount) OVER ( ROWS BETWEEN 2 PRECEDING AND CURRENT ROW ) as moving_avgFROM orders; 或者要查看当前订单和它的上一单和下一单的金额总和。 SELECT order_no, total_amount, SUM(total_amount) OVER ( ORDER BY created_at ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) as context_sumFROM orders; range的使用range按照按值的逻辑范围，一般用于时间范围，比如这样 SUM(amount) OVER ( PARTITION BY user_id ORDER BY create_time RANGE BETWEEN INTERVAL 7 DAY PRECEDING AND CURRENT ROW) 来统计最近 7 天订单总额 range和rows的区别假如有这样一个表 id score 1 10 2 10 3 20 4 30 5 30 用rows来新增一个求和列的话 SELECT id, score, SUM(score) OVER ( ORDER BY score ROWS BETWEEN 1 PRECEDING AND CURRENT ROW ) AS sum_rowsFROM score; 就会是这样的 +----+-------+----------+| id | score | sum_rows |+----+-------+----------+| 1 | 10 | 10 || 2 | 10 | 20 || 3 | 20 | 30 || 4 | 30 | 50 || 5 | 30 | 60 |+----+-------+----------+5 rows in set (0.0005 sec) 即使分数一样，也是一行一行数。符合直觉吧 而如果换成range SELECT id, score, SUM(score) OVER ( ORDER BY score RANGE BETWEEN 1 PRECEDING AND CURRENT ROW ) AS sum_rowsFROM score; 就会是这样的 +----+-------+----------+| id | score | sum_rows |+----+-------+----------+| 1 | 10 | 20 || 2 | 10 | 20 || 3 | 20 | 20 || 4 | 30 | 60 || 5 | 30 | 60 |+----+-------+----------+5 rows in set (0.0004 sec) 因为上面那个RANGE，说人话的意思就是，把 score 在 [当前值 - 1, 当前值] 这个区间里的所有行加起来 所以 score RANGE 区间 被算的 score 结果 10 [9,10] 10,10 20 10 [9,10] 10,10 20 20 [19,20] 20 20 30 [29,30] 30,30 60 30 [29,30] 30,30 60 关于窗口函数更多内容，可以前往深入MySQL窗口函数：原理和应用-腾讯云开发者社区-腾讯云 处理json数据MySQL 从 5.7 版本开始原生支持 JSON 数据类型 什么时候用json 不确定的属性（动态 Schema）： 电商的商品表。衣服有“颜色、尺码”，手机有“内存、屏幕分辨率”，书有“作者、ISBN”。如果为每个属性都建一列，表会变得极其宽且难以维护。用 JSON 字段存 attributes 是完美方案。 用户个性化配置： 用户的偏好设置、UI 布局配置、通知开关等，这些字段经常变动，没必要每次加配置都去改表结构。 接口数据存储日志： 直接存储调用第三方 API 返回的 JSON 结果，或者存储前端提交的复杂表单数据，用于留存或后续审计。 稀疏数据： 一个表有 100 个列，但大部分行只有其中 5 个列有值，其他都是 NULL。用 JSON 可以节省空间并简化结构。 上手使用json在创建表的时候直接将列的数据类型指定为json CREATE TABLE products ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), details JSON -- 定义 JSON 类型); 插入数据直接插入json字符串即可 INSERT INTO products (name, details) VALUES (T-Shirt, color: white, size: L, tags: [summer, casual]),(iPhone 15, color: black, storage: 256GB, screen: 6.1); 执行后表的内容就是这样的 MySQL localhost:3306 ssl mall_db_simple SQL select * from products;+----+-----------+---------------------------------------------------------------+| id | name | details |+----+-----------+---------------------------------------------------------------+| 1 | T-Shirt | size: L, tags: [summer, casual], color: white || 2 | iPhone 15 | color: black, screen: 6.1, storage: 256GB |+----+-----------+---------------------------------------------------------------+2 rows in set (0.0004 sec) json相关函数读取类 函数 操作符 作用 语法示例 结果 说明 - 提取值 (保留引号) 提取指定路径的节点，返回的是 JSON 类型。 SELECT @j-$.name; Mario注意带有双引号，通常用于进一步处理 JSON。 - 提取值 (去引号) 提取并转为字符串数字，最推荐用于显示或比较。 SELECT @j-$.name; Mario双引号没了，直接变成了字符串。 JSON_KEYS 获取所有 Key 返回对象顶层所有的键名数组。 SELECT JSON_KEYS(@j); [name, score, tags]常用于查看 JSON 结构。 JSON_LENGTH 获取长度 对象的键数量或数组的元素个数。 SELECT JSON_LENGTH(@j, $.tags); 2查看 tags 数组里有几个元素。 修改类 函数 作用 语法示例 结果 说明 JSON_SET (万能) 插入或更新Key 存在则更新，不存在则插入。 SELECT JSON_SET(@j, $.score, 200, $.age, 18); {name:..., score: 200, age: 18}最推荐使用，类似 Upsert。 JSON_INSERT 只插入Key 不存在才插入，存在则忽略。 SELECT JSON_INSERT(@j, $.score, 200); {score: 100...}因为 score 已存在，所以不改。 JSON_REPLACE 只更新Key 存在才更新，不存在则忽略。 SELECT JSON_REPLACE(@j, $.age, 18); {name:...}因为 age 不存在，所以不加。 JSON_REMOVE 删除删除指定路径的节点。 SELECT JSON_REMOVE(@j, $.tags); {name: Mario, score: 100}tags 字段被删掉了。 JSON_ARRAY_APPEND 数组追加向数组类型的字段追加元素。 SELECT JSON_ARRAY_APPEND(@j, $.tags, new); ...tags: [red, game, new] 查询与搜索类 函数 作用 语法示例 结果 说明 JSON_CONTAINS 包含检查检查 JSON 文档是否包含指定的值（精确匹配）。 SELECT JSON_CONTAINS(@j, red, $.tags); 1 (True)判断 tags 数组里有没有 “red”。注意字符串要多包一层引号。 JSON_SEARCH 搜索路径查找某个值在 JSON 中的路径。 SELECT JSON_SEARCH(@j, one, game); $.tags[1]告诉你 “game” 在哪里。 JSON_VALID 格式校验判断字符串是否为合法的 JSON。 SELECT JSON_VALID({a:1}); 1 (True)常用于清洗脏数据。 构造类 函数 作用 语法示例 结果 说明 JSON_OBJECT 创建对象将键值对列表转为 JSON 对象。 SELECT JSON_OBJECT(id, 1, name, A); {id: 1, name: A} JSON_ARRAY 创建数组将值列表转为 JSON 数组。 SELECT JSON_ARRAY(a, 1, NOW()); [a, 1, 2023-10-01...] JSON_ARRAYAGG 聚合为数组配合 GROUP BY，将多行数据聚合为一个 JSON 数组。 SELECT JSON_ARRAYAGG(name) FROM users; [Alice, Bob, Charlie]非常有用的聚合函数。 查询json列中的数据使用 - 和 - 操作符： -：返回带引号的 JSON 结果（例如 white）。 -：返回去引号的字符串结果（例如 white）。 比如我要查询每个产品的名称和颜色 select name,details-$.color as color from products; 执行后的输出是这样的 +-----------+-------+| name | color |+-----------+-------+| T-Shirt | white || iPhone 15 | black |+-----------+-------+2 rows in set (0.0020 sec) 或者我要查询详情中包含 “storage” 属性的商品 select * from products where details-$.storage is not null; 执行后的输出是这样的 +----+-----------+---------------------------------------------------------+| id | name | details |+----+-----------+---------------------------------------------------------+| 2 | iPhone 15 | color: black, screen: 6.1, storage: 256GB |+----+-----------+---------------------------------------------------------+1 row in set (0.0005 sec) 或者如果要查找json的某个数组中包含某个值的行，使用JSON_CONTAINS() select * from products where json_contains(details,summer,$.tags); 执行后的输出结果是这样的 +----+---------+---------------------------------------------------------------+| id | name | details |+----+---------+---------------------------------------------------------------+| 1 | T-Shirt | size: L, tags: [summer, casual], color: white |+----+---------+---------------------------------------------------------------+1 row in set (0.0010 sec) 修改json数据不要把整个 JSON 拿出来改完再覆盖回去，使用原生函数效率更高。 比如我要给所有商品增加一个NB属性，并把color设置成blue update products set details = json_set(details,$.color,blue,$.NB,true); 执行的效果是 +----+-----------+----------------------------------------------------------------------------+| id | name | details |+----+-----------+----------------------------------------------------------------------------+| 1 | T-Shirt | NB: true, size: L, tags: [summer, casual], color: blue || 2 | iPhone 15 | NB: true, color: blue, screen: 6.1, storage: 256GB |+----+-----------+----------------------------------------------------------------------------+2 rows in set (0.0004 sec) 如果要删除NB属性 update products set details = json_remove(details,$.NB); 执行的效果是 +----+-----------+--------------------------------------------------------------+| id | name | details |+----+-----------+--------------------------------------------------------------+| 1 | T-Shirt | size: L, tags: [summer, casual], color: blue || 2 | iPhone 15 | color: blue, screen: 6.1, storage: 256GB |+----+-----------+--------------------------------------------------------------+2 rows in set (0.0004 sec) 使用json需要注意的json列本身不能直接建立索引。如果需要经常需要在 WHERE 子句中根据 json里的某个字段，需要使用虚拟列。并给虚拟列添加索引age’ 20; ALTER TABLE users ADD COLUMN v_age INT GENERATED ALWAYS AS (profile-$.age) VIRTUAL;CREATE INDEX idx_age ON users(v_age);SELECT * FROM users WHERE v_age 20; -- 或者SELECT * FROM users WHERE profile-$.age 20; json存储会比普通字段占用更多空间。不要把 json当作大文本存，尽量保持 json结构精简。 CTE (通用表表达式)可以把 CTE 理解为 “临时命名的结果集”。它就像是一个在当前 SQL 语句中临时定义的“虚拟表”或“变量”，可以像查询普通表一样查询它。 CTE 主要用于解决以下三个痛点： 提高代码可读性（最常用）： 以前写复杂的 SQL，会使用大量的嵌套子查询（Subquery），一层套一层，像“洋葱”一样，非常难以阅读和维护。 CTE 可以把逻辑扁平化，先定义数据 A，再定义数据 B，最后查询 A 和 B，逻辑像写代码一样自上而下。 逻辑复用： 如果同一个子查询结果在主查询中需要被用到多次（例如 join 两次），用 CTE 只需要定义一次，后面引用即可，不用重复写子查询代码。 递归查询（杀手级功能）： 处理树形结构（如：公司组织架构、商品多级分类、评论回复楼层）时，必须使用递归 CTE (WITH RECURSIVE)。 CTE的语法WITH cte_name (列名1, 列名2, ...) AS ( -- 这里写你的子查询 SELECT ...)-- 紧接着写主查询，可以使用上面的 cte_nameSELECT * FROM cte_name; 使用CTE还记得上面那个每个城市消费前三的例子吗 SELECT * FROM(SELECT u.city, u.username, IFNULL(SUM(o.total_amount),0) as money, RANK() OVER( PARTITION BY u.city ORDER BY SUM(o.total_amount) DESC ) as ranklistFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.city, u.username)AS tWHERE t.ranklist = 3 AND t.money 0; 如果把它换成CTE写法就是 -- 1. 先定义“带排名的用户列表”WITH UserRanks AS ( SELECT u.city, u.username, IFNULL(SUM(o.total_amount),0) as money, RANK() OVER(PARTITION BY u.city ORDER BY SUM(o.total_amount) DESC) as ranklist FROM users AS u LEFT JOIN orders AS o ON u.id = o.user_id GROUP BY u.city, u.username)-- 2. 再对这个列表进行筛选SELECT * FROM UserRanks WHERE ranklist = 3 AND money 0; 看着好像没什么差别？确实，在这个简单例子里，确实只是“排版”的区别。 分步聚合我要找出总消费金额 5000的用户，并列出他们的姓名、电话、城市以及具体的消费总额。 先写一个查询列出所有用户消费金额 select user_id, SUM(total_amount) AS total_spentFROM orders GROUP BY user_id; 然后把这表作为一个UserSpent临时表，和用户表内连接起来就是这样 WITH UserSpent AS ( select user_id, SUM(total_amount) AS total_spent FROM orders GROUP BY user_id)SELECT u.username, u.city, u.phone, us.total_spentFROM users AS uINNER JOIN UserSpent AS us ON u.id = us.user_idWHERE us.total_spent 5000ORDER BY us.total_spent DESC; 再用到窗口函数，给他加个排名 WITH UserSpent AS ( select user_id, SUM(total_amount) AS total_spent FROM orders GROUP BY user_id)SELECT u.username, u.city, u.phone, us.total_spent, RANK() OVER(ORDER BY us.total_spent DESC) as `rank`FROM users AS uINNER JOIN UserSpent AS us ON u.id = us.user_idWHERE us.total_spent 5000ORDER BY us.total_spent DESC; 执行出来的结果就是这样的 +----------+------------+-------------+-------------+------+| username | city | phone | total_spent | rank |+----------+------------+-------------+-------------+------+| 车燕 | 淮安市 | 15138603669 | 33505.00 | 1 || 谢梅 | 丽华市 | 15198232698 | 31875.00 | 2 |....省略若干行...| 梁秀华 | 慧市 | 13235808817 | 5049.00 | 502 || 陈莉 | 重庆县 | 18953949093 | 5022.00 | 503 |+----------+------------+-------------+-------------+------+503 rows in set (0.0126 sec) 复用逻辑链式CTE查看 “数码” 类目下，各个商品的销售额，以及该商品占整个“数码”类目总销售额的百分比。 需要下面两个数据 每个数码商品的销售额（Group By product_id）。 数码类的总销售额（计算要用到它来做分母）。 WITH DigitalProductSales AS ( -- 1. 先把数码类的所有销售明细算出来 SELECT p.name AS product_name, SUM(oi.quantity * oi.price) AS prod_total FROM order_items oi JOIN products p ON oi.product_id = p.id WHERE p.category = 数码 GROUP BY p.name),TotalDigitalSales AS ( -- 2. 复用上面的 CTE！计算数码类的总销售额 -- 这里直接查询了定义好的 DigitalProductSales，不用再去 join 原始表了 SELECT SUM(prod_total) AS cat_total FROM DigitalProductSales)-- 3. 主查询：计算占比SELECT dps.product_name, dps.prod_total, tds.cat_total, CONCAT(ROUND((dps.prod_total / tds.cat_total) * 100, 2), %) AS percentFROM DigitalProductSales dpsCROSS JOIN TotalDigitalSales tdsORDER BY dps.prod_total DESC; 可以看到，下面的TotalDigitalSales是可以直接使用DigitalProductSales的数据的。定义多个CTE使用逗号隔开 但是这么写其实不太好，我也只是为了演示CTE之间可以调用数据。 这种需求应该使用窗口函数 SELECT p.name AS product_name, SUM(oi.quantity * oi.price) AS prod_total, SUM(SUM(oi.quantity * oi.price)) OVER() AS cat_total, CONCAT(ROUND(SUM(oi.quantity * oi.price) / SUM(SUM(oi.quantity * oi.price)) OVER() * 100, 2), %) AS percentFROM order_items oiJOIN products p ON oi.product_id = p.idWHERE p.category = 数码GROUP BY p.nameORDER BY prod_total DESC; 执行效果是一样的。窗口函数更简单 +--------------+------------+------------+---------+| product_name | prod_total | cat_total | percent |+--------------+------------+------------+---------+| 数码-我的 | 299052.00 | 1448330.00 | 20.65% || 数码-项目 | 238022.00 | 1448330.00 | 16.43% || 数码-喜欢 | 231068.00 | 1448330.00 | 15.95% || 数码-不能 | 123622.00 | 1448330.00 | 8.54% || 数码-比较 | 119634.00 | 1448330.00 | 8.26% || 数码-起来 | 107300.00 | 1448330.00 | 7.41% || 数码-以上 | 101840.00 | 1448330.00 | 7.03% || 数码-行业 | 67035.00 | 1448330.00 | 4.63% || 数码-开发 | 57277.00 | 1448330.00 | 3.95% || 数码-全国 | 54400.00 | 1448330.00 | 3.76% || 数码-一般 | 49080.00 | 1448330.00 | 3.39% |+--------------+------------+------------+---------+11 rows in set (0.0343 sec) 再来个例子，生成一个“月度销售报表”，包含：月份、当月订单数、当月总金额、以及环比上个月的增长率。 同样，先把数据按照月份分组统计 SELECT DATE_FORMAT(created_at, %Y-%m) AS sale_month, SUM(total_amount) AS total_moneyFROM ordersGROUP BY DATE_FORMAT(created_at, %Y-%m); 然后把这个查询作为一个CTE，在另一个CTE里使用窗口函数创建一个上一个月的列 WITH MonthlyStats AS ( SELECT DATE_FORMAT(created_at, %Y-%m) AS sale_month, SUM(total_amount) AS total_money FROM orders GROUP BY DATE_FORMAT(created_at, %Y-%m)),GrowthStats AS ( SELECT sale_month, total_money, LAG(total_money, 1) OVER (ORDER BY sale_month) AS last_month_money FROM MonthlyStats) 最后再把数据显示出来 WITH MonthlyStats AS ( SELECT DATE_FORMAT(created_at, %Y-%m) AS sale_month, SUM(total_amount) AS total_money FROM orders GROUP BY DATE_FORMAT(created_at, %Y-%m)),GrowthStats AS ( SELECT sale_month, total_money, LAG(total_money, 1) OVER (ORDER BY sale_month) AS last_month_money FROM MonthlyStats)SELECT sale_month, total_money, last_month_money, CONCAT(ROUND((total_money - last_month_money) / last_month_money * 100, 2), %) AS growth_rateFROM GrowthStatsORDER BY sale_month; 执行后得到的结果就是这样的 +------------+-------------+------------------+-------------+| sale_month | total_money | last_month_money | growth_rate |+------------+-------------+------------------+-------------+| 2025-01 | 540403.00 | NULL | NULL || 2025-02 | 489717.00 | 540403.00 | -9.38% || 2025-03 | 538732.00 | 489717.00 | 10.01% || 2025-04 | 509465.00 | 538732.00 | -5.43% || 2025-05 | 573503.00 | 509465.00 | 12.57% || 2025-06 | 391503.00 | 573503.00 | -31.73% || 2025-07 | 429322.00 | 391503.00 | 9.66% || 2025-08 | 505246.00 | 429322.00 | 17.68% || 2025-09 | 501646.00 | 505246.00 | -0.71% || 2025-10 | 536669.00 | 501646.00 | 6.98% || 2025-11 | 632946.00 | 536669.00 | 17.94% || 2025-12 | 456490.00 | 632946.00 | -27.88% || 2026-01 | 98514.00 | 456490.00 | -78.42% |+------------+-------------+------------------+-------------+13 rows in set (0.0085 sec) 其实这里就能看到CTE的作用了，因为这种情况下如果不用CTE，整个SQL会非常难读难改像一坨大的，就像这样: SELECT DATE_FORMAT(created_at, %Y-%m) AS sale_month, SUM(total_amount) AS total_money, LAG(SUM(total_amount), 1) OVER (ORDER BY DATE_FORMAT(created_at, %Y-%m)) AS last_month_money, CONCAT(ROUND((SUM(total_amount) - LAG(SUM(total_amount), 1) OVER (ORDER BY DATE_FORMAT(created_at, %Y-%m)) ) / LAG(SUM(total_amount), 1) OVER (ORDER BY DATE_FORMAT(created_at, %Y-%m)) * 100, 2), %) AS growth_rateFROM ordersGROUP BY DATE_FORMAT(created_at, %Y-%m); 两者执行效果是一样的，但是后者会让人一眼就放弃 主要还是因为SQL 的一个核心规则：在同一个 SELECT 层级中，定义的“别名”（Alias）不能在同一层级的其他计算中直接使用。 递归(WITH RECURSIVE)在CTE中是可以调用自己的 WITH RECURSIVE NumSeries AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM NumSeries WHERE n 5)SELECT * FROM NumSeries; 注意，SQL 的递归不是“函数调用”，而是结果集自我扩张。UNION ALL 上面的语句只执行1次，下面的语句会执行多次，且每次引用的 NumSeries 指的不是整个表，而是上一轮刚刚产生的那一行数据。 递归 CTE 根本不是函数递归，它是：先算出一行，再用这行算出下一行，再用“新算出来的那行”继续算，直到算不出新行 SELECT n + 1 FROM NumSeries WHERE n 5 这里面的NumSeries,把它想象成执行NumSeries最新一行数据的指针 执行逻辑就类似于下面的Python程序 nums = [1]while True: new_nums = [] for n in nums: if n 5: new_nums.append(n + 1) if not new_nums: break nums.extend(new_nums)print(nums) 递归 CTE 每一轮只用“上一轮新产生的行”去算下一轮，不会反复拿旧行再算一遍，否则它会 无限重复、无限膨胀。 递归使用这个模板 WITH RECURSIVE cte_name AS ( -- 1. 初始查询（种子）：你想从谁开始找？ SELECT ... UNION ALL -- 2. 递归查询（套娃）：逻辑通常是 JOIN cte_name SELECT ... FROM table JOIN cte_name ON table.parent_id = cte_name.id -- 或者是 cte.id = table.parent_id)SELECT * FROM cte_name; 来个例子： 假设表 employees 结构如下： id name manager_id (上司ID) 1 大老板 NULL 2 技术总监 1 3 产品总监 1 4 程序员A 2 5 程序员B 2 6 实习生 4 要查出技术总监 (id2) 手下的所有人（包括下属的下属，一直到底）。 sql语句是这么写的 WITH RECURSIVE Subordinates AS ( -- 启动：先找到那个“根”节点（技术总监） SELECT id, name, manager_id, 1 AS depth FROM employees WHERE id = 2 -- 从 ID=2 开始往下找 UNION ALL -- 循环：找上一轮找到的人的下属,s 是上一轮找到的结果集 SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e JOIN Subordinates s ON e.manager_id = s.id -- 员工的 manager_id 等于 上一轮找到的人的 id)SELECT * FROM Subordinates; 先通过WHERE id = 2获取到了技术总监那行的数据，然后再把那行再和原employees表通过技术总监的manager_id和id内连接。显然内连接的结果就是程序员A和程序员B两行。 同理，再用程序员A的id和原表的manager_id内连接，得到实习生那行。 用程序员B的的id和原表的manager_id内连接，得到的是空 用实习生的的id和原表的manager_id内连接，得到的是空 自此，循环结束 性能上的微小区别在 MySQL 8.0 中，CTE 还有一个特性叫 Materialization（物化临时表缓存）。 普通子查询：有时候优化器会把子查询“打散”，合并到主查询里去执行（Derived Merge）。 CTE：如果你的 CTE 逻辑非常复杂（比如计算量巨大），且在主查询里被引用了多次，MySQL 可能会选择把这个 CTE 的结果存成一个内部临时表（只算一次），然后多次读取。这在某些特定场景下比多次执行子查询要快。 总之只要满足以下任意一点，就建议用 CTE： 同一个子查询结果，要在后面用 2 次以上（复用）。 需要递归查询（树形结构）。 逻辑太长太深，需要把代码拆分成“第一步算这个、第二步算那个”来提高可读性。 触发器Mysql的触发器可以在数据插入、更新或删除时自动执行相应的逻辑 主要作用包括： 自动执行：触发器可以在特定事件发生时自动执行预定义的操作，无需手动调用。 数据完整性：通过在数据库操作前或后执行验证和修改操作，触发器能够维护数据的完整性和一致性。 审计和日志记录：触发器可用于记录对数据库进行的操作，便于审计和追踪数据变更。 复杂业务逻辑：触发器允许在数据库级别实现复杂的业务逻辑，从而确保数据操作的一致性和正确性。 触发器的SQL语句是这样: CREATE TRIGGER 触发器名BEFORE | AFTER INSERT | UPDATE | DELETEON 表名FOR EACH ROWBEGIN -- 触发器逻辑END; 在触发器逻辑中可以使用OLD和NEW关键字指向原有行或者新的行。但是要看触发事件 触发事件 关键字 含义 能用 NEW 吗？ 能用 OLD 吗？ 典型用途 INSERT NEW 即将插入的新数据 ✅ 可用 ❌ 没有旧数据 校验新数据格式、自动填充字段 UPDATE NEW 改成什么样了 ✅ 可用 ✅ 可用 记录”从xx改为xx”的日志 DELETE OLD 即将消失的数据 ❌ 没有新数据 ✅ 可用 做备份、归档 创建触发器比如我要给订单表加一个触发器，新增一个订单就扣除一个库存 那就是在order_items加一个INSERT监视器，获取order_items表中NEW这一行的product_id和quantity，即购买商品的ID和购买数量 然后再到products表里，根据购买商品的ID，扣除相应的库存 DELIMITER $$CREATE TRIGGER koukucunBEFORE INSERTON order_itemsFOR EACH ROWBEGIN\tUPDATE products SET products.stock = products.stock - NEW.quantity WHERE NEW.product_id = products.id;END $$DELIMITER ; DELIMITER是用来更改SQL语句的结尾的。因为我们要在触发器逻辑里写结束符号。所以在外部使用DELIMITER暂时修改一下结束符号 但是这么写又有问题来了，还记得上一篇文章说的超卖问题吗。那个解决方法在这里不适用了。如果加上AND product.stock NEW.quantity的话，这么执行不会报错，但是也不会修改库存数据。 正确的做法是在触发器里就检测库存 DELIMITER $$CREATE TRIGGER koukucunBEFORE INSERT ON order_itemsFOR EACH ROWBEGIN -- 1. 定义一个变量存当前库存 DECLARE current_stock INT; -- 2. 查出当前商品的库存 SELECT stock INTO current_stock FROM products WHERE id = NEW.product_id; -- 明确指定 id 是产品的 id -- 3. 判断库存够不够 IF current_stock NEW.quantity THEN -- 4. 如果不够，抛出异常！这会中断 INSERT 操作，订单创建失败 SIGNAL SQLSTATE 45000 SET MESSAGE_TEXT = 库存不足，无法下单; ELSE -- 5. 如果够，执行扣减 UPDATE products SET stock = stock - NEW.quantity WHERE id = NEW.product_id; END IF;END $$DELIMITER ; 这样如果库存不足的话，INSERT语句就会直接创建失败了 使用触发器现在products表里随便找个商品看看库存有多少个？ MySQL localhost:3306 ssl mall_db_simple SQL select * from products limit 1;+----+-----------+----------+--------+-------+--------+| id | name | category | price | stock | status |+----+-----------+----------+--------+-------+--------+| 1 | 零食-世界 | 零食 | 535.00 | 999 | 1 |+----+-----------+----------+--------+-------+--------+1 row in set (0.0043 sec) 可以看到id为1的商品还剩999个。现在向order_items插入一条订单数据看看，这里只为了演示触发器的使用我就不加order_id和price了。 insert into order_items (product_id,quantity) values (1,500); 执行后会弹出警告 Warning (code 1364): Field order_id doesnt have a default value 这个正常我们来看看库存现在咋样了 MySQL localhost:3306 ssl mall_db_simple SQL select * from products limit 1;+----+-----------+----------+--------+-------+--------+| id | name | category | price | stock | status |+----+-----------+----------+--------+-------+--------+| 1 | 零食-世界 | 零食 | 535.00 | 499 | 1 |+----+-----------+----------+--------+-------+--------+1 row in set (0.0012 sec) 库存减掉500个了，现在来试试超卖的情况 MySQL localhost:3306 ssl mall_db_simple SQL insert into order_items (product_id,quantity) values (1,900);ERROR: 1644 (45000): 库存不足，无法下单MySQL localhost:3306 ssl mall_db_simple SQL select * from products limit 1;+----+-----------+----------+--------+-------+--------+| id | name | category | price | stock | status |+----+-----------+----------+--------+-------+--------+| 1 | 零食-世界 | 零食 | 535.00 | 499 | 1 |+----+-----------+----------+--------+-------+--------+1 row in set (0.0004 sec) 直接报错了，库存也没减少 列出删除触发器要列出触发器直接使用SHOW关键字 MySQL localhost:3306 ssl mall_db_simple SQL show TRIGGERS;+----------+--------+-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+------------------------+-----------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+| Trigger | Event | Table | Statement | Timing | Created | sql_mode | Definer | character_set_client | collation_connection | Database Collation |+----------+--------+-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+------------------------+-----------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+| koukucun | INSERT | order_items | BEGIN -- 1. 定义一个变量存当前库存 DECLARE current_stock INT; -- 2. 查出当前商品的库存 SELECT stock INTO current_stock FROM products WHERE products.id = NEW.product_id; -- 3. 判断库存够不够 IF current_stock NEW.quantity THEN -- 4. 如果不够，抛出异常！这会中断 INSERT 操作，订单创建失败 SIGNAL SQLSTATE 45000 SET MESSAGE_TEXT = 库存不足，无法下单; ELSE -- 5. 如果够，执行扣减 UPDATE products SET stock = stock - NEW.quantity WHERE id = NEW.product_id; END IF;END | BEFORE | 2026-01-06 18:07:03.53 | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION | root@localhost | utf8mb4 | utf8mb4_0900_ai_ci | utf8mb4_0900_ai_ci |+----------+--------+-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+------------------------+-----------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+1 row in set (0.0015 sec) 可以看到触发器内会保存注释，毕竟SQL不用编译成二进制执行 删除触发器使用DROP关键字即可。DROP TRIGGER 触发器名不演示了 一个不要使用触发器的例子比如一个用户注销后，在用户表挂一个DELETE触发器自动去删除其他表比如评论表，订单表中这个用户的数据，这样后端写用户注销的接口的接口只用传一个delete from users where xxx;？ 如果事务隔离级别使用的是RR，将要面对间隙锁。最坏情况下，如果订单表第一条是这个用户的数据，最后一条也是这个用户的数据，间隙锁会将整张表锁住！此时其他操作要等到触发器删除完订单表的内容才会把整张订单表从锁里放出来。 那如果把隔离等级换成RC？如果在没有建立索引的情况下，就有可能遇到死锁了: 假如 orders 表里的 user_id 没有索引。 事务 A 执行 DELETE FROM orders WHERE user_id = 123：因为没有索引，MySQL 必须进行全表扫描（或者主键扫描）来找 123。在 RC 级别下，虽然它会边扫描边释放不匹配的锁，但在扫描过程中，它实际上扫过了所有的行。 事务 B 执行 DELETE FROM orders WHERE user_id = 456它也要全表扫描。 这时候，如果扫描顺序稍微撞一下，或者在扫描过程中互相等待锁（比如 A 扫到了 456 的行准备判断，B 扫到了 123 的行准备判断），就可能死锁，或者退化成严重的锁等待。 既然如此，那如果把隔离等级换成RC，并给相应的列加上索引呢？技术上是可行的。不同的注销事务只会锁目标行，事务 A 删用户 123，事务 B 删用户 456，互不干扰。 但是这样又会遇到下面的问题 隐式逻辑难以维护触发器有个特性就是要去show TRIGGERS;才能看到这有个触发器 假如我写了触发器在数据库里，后端注销接口我只传了个delete from users where xxx一年后我提桶跑路了，新来的一看就懵了，为什么每次一删用户表里的数据别的表里的数据也跟着没了？翻遍整个后端代码都没看见这个逻辑。直到突然想起连上Mysql发现有个触发器 这是“业务逻辑泄露”。代码是显性的，触发器是隐性的。在大型系统中，逻辑应该尽可能集中在代码层，做到“所见即所得”。 大量数据阻塞性能假如注销的是个顶级老资历，订单表里有大量他的订单，那就可能阻塞性能。但是这不是因为触发器导致的。不过可以单独在后端写，分批删除这位老资历的数据。防止数据库在这个大事务中卡死，甚至把数据库的 Undo Log 撑爆。 并不是说把触发器的逻辑放在后端就不卡了，而是放在后端让我们拥有了把大任务拆解成小任务的能力。 推荐使用触发器的场景审计与数据留痕说人话就是日志。如果需要记录某张核心表（比如 balance 余额表）的所有变动历史。哪怕是 DBA 半夜偷偷连上数据库用命令行改了一个数字，或者有一个陈旧的 PHP 后台改了数据，这条修改记录也要被记下来。 这个后端做不了，后端代码只能监控通过后端 API 发起的请求。它管不了直接操作数据库的行为，也管不了别的微服务或者遗留系统对数据库的修改。 复杂的强数据约束说人话就是防止超买超卖，就比如上面给的那个例子。金融、库存等对数据准确性要求高的。不过这是兜底的，后端该检验要是要检验的 自动更新统计数据论坛里有一个 boards（板块）表，里面有个字段 post_count（帖子总数）。不想每次展示板块都去 posts 表 SELECT COUNT(*)，因为太慢了。 有人发帖（INSERT posts）：UPDATE boards SET post_count = post_count + 1 WHERE id = NEW.board_id 有人删帖（DELETE posts）：UPDATE boards SET post_count = post_count - 1 WHERE id = OLD.board_id 如果不写在触发器里，就需要在后端代码的每一个“发帖、删帖、审核通过、隐藏帖子”的地方都记得去更新这个计数，漏一个地方数据就不准了。 但是并发不能高，并发高boards那行会被锁死 存储过程好比在后端写的函数，只不过这个函数是用 SQL 写的，而且保存在数据库里。客户端不用发一堆 SQL，只发一个命令：“执行函数 A，参数是 X”。数据库在内部自己算完，把结果吐出来。 比如我要写一个充值功能，如果充值金额大于100再多送5元 DELIMITER $$CREATE PROCEDURE recharge_and_bonus(IN p_user_id INT, IN p_amount DECIMAL(10,2))BEGIN -- 1. 充钱 UPDATE users SET balance = balance + p_amount WHERE id = p_user_id; -- 2. 送钱 IF p_amount = 100 THEN UPDATE users SET balance = balance + 5 WHERE id = p_user_id; -- 再送5元！ END IF; -- 3. 返回最新余额 SELECT balance, points FROM users WHERE id = p_user_id;END $$DELIMITER ; 后端代码只需要发一句 SQL就能完成充值操作： CALL recharge_and_bonus(1, 200); 但是现在没啥人用了 难以调试：没法打断点，报错信息模糊。 难以版本控制：代码都在数据库里，Git 很难管理它。 计算压力转移：把计算逻辑压在数据库头上。数据库是很难扩容的，应用服务器却很容易扩容。 所以现在的原则是：“计算下移（去后端），存储上移（回数据库）” 所以这里就不深入了，就当是填个坑","tags":["notebook","Mysql","Database"]},{"title":"Mysql攻略-高级查询到进阶功能","path":"/2026/01/02/mysql-super/","content":"你点开本文我就当你已经知道Mysql基础了，看完本文你将速通：函数，分组与统计，多表查询，子查询，索引，事务，间隙锁。 由于篇幅问题，窗口函数，悲观乐观锁，处理 JSON 数据，复杂逻辑处理(if else)，性能分析，存储过程与触发器等等高级功能会放到下一篇文章。全部看完你就瞬间变成Mysql高手 先用下面的py模拟一堆数据进去 import pymysqlfrom faker import Fakerimport randomfrom datetime import datetime# ================= 配置区域 =================DB_CONFIG = host: localhost, user: root, password: 123456, # ⚠️ 记得改你的密码 port: 3306, charset: utf8mb4DB_NAME = mall_db_simple # 依然使用纯净库# 数据量设置NUM_USERS = 200 # 200个用户NUM_PRODUCTS = 50 # 50种商品NUM_ORDERS = 100 # 100个订单 (生成的 order_items 会有 2000~4000 条)# ===========================================fake = Faker(zh_CN)def get_connection(use_db=True): conf = DB_CONFIG.copy() if use_db: conf[db] = DB_NAME return pymysql.connect(**conf)def init_db(): print(f🔄 初始化纯净版数据库: DB_NAME...) conn = get_connection(use_db=False) cursor = conn.cursor() cursor.execute(fCREATE DATABASE IF NOT EXISTS DB_NAME DEFAULT CHARSET utf8mb4;) cursor.execute(fUSE DB_NAME;) # 清理旧表 cursor.execute(DROP TABLE IF EXISTS order_items;) cursor.execute(DROP TABLE IF EXISTS orders;) cursor.execute(DROP TABLE IF EXISTS products;) cursor.execute(DROP TABLE IF EXISTS users;) # === 表结构保持“素颜”（只有主键） === sql_users = CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), phone VARCHAR(20), city VARCHAR(50), created_at DATETIME ); sql_products = CREATE TABLE products ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100), category VARCHAR(50), price DECIMAL(10, 2), stock INT, status TINYINT ); sql_orders = CREATE TABLE orders ( id INT AUTO_INCREMENT PRIMARY KEY, user_id INT NOT NULL, order_no VARCHAR(50), total_amount DECIMAL(12, 2), -- 这个金额是经过计算算出来的 status TINYINT, created_at DATETIME ); sql_order_items = CREATE TABLE order_items ( id INT AUTO_INCREMENT PRIMARY KEY, order_id INT NOT NULL, product_id INT NOT NULL, quantity INT, price DECIMAL(10, 2) ); cursor.execute(sql_users) cursor.execute(sql_products) cursor.execute(sql_orders) cursor.execute(sql_order_items) conn.commit() conn.close() print(✅ 表结构重置完成！)def generate_data(): conn = get_connection() cursor = conn.cursor() # --- 1. 生成用户 --- print(👤 正在生成用户...) users_data = [] for _ in range(NUM_USERS): users_data.append((fake.name(), fake.email(), fake.phone_number(), fake.city(), fake.date_time())) cursor.executemany(INSERT INTO users (username, email, phone, city, created_at) VALUES (%s, %s, %s, %s, %s), users_data) # --- 2. 生成商品 --- print(📦 正在生成商品...) products_data = [] # 搞点真实的分类 categories = [数码, 零食, 书籍, 服装, 家居] for _ in range(NUM_PRODUCTS): cat = random.choice(categories) price = random.randint(10, 2000) # 价格在10块到2000块之间 products_data.append((fcat-fake.word(), cat, price, 999, 1)) cursor.executemany(INSERT INTO products (name, category, price, stock, status) VALUES (%s, %s, %s, %s, %s), products_data) conn.commit() # 准备缓存数据，方便下面生成订单用 cursor.execute(SELECT id FROM users) user_ids = [r[0] for r in cursor.fetchall()] cursor.execute(SELECT id, price FROM products) # 变成字典 id: price，方便查价格 products_map = r[0]: float(r[1]) for r in cursor.fetchall() product_ids_list = list(products_map.keys()) # --- 3. 生成复杂的订单 --- print(📝 正在生成复杂订单 (多商品/多数量)...) batch_orders = [] batch_items = [] for i in range(1, NUM_ORDERS + 1): # 3.1 随机选人、时间、状态 u_id = random.choice(user_ids) created_at = fake.date_time_between(start_date=-1y, end_date=now) order_no = fORDcreated_at.strftime(%Y%m%d)i:05d status = random.choice([0, 1, 2, 3]) # 3.2 决定这个订单买几种商品 (1 到 5 种) items_count = random.randint(1, 5) # 从商品库里随机抽 items_count 个商品ID (不重复) selected_pids = random.sample(product_ids_list, items_count) current_order_total = 0.0 # 3.3 遍历生成的商品，算钱，生成明细 for pid in selected_pids: # 决定买几个 (1 到 3 个) qty = random.randint(1, 3) price = products_map[pid] # 累加总金额 current_order_total += price * qty # 添加到 items 列表 (注意这里用了 i 作为 order_id) batch_items.append((i, pid, qty, price)) # 3.4 添加到 orders 列表 batch_orders.append((u_id, order_no, current_order_total, status, created_at)) # 每500个提交一次，防止列表太大撑爆内存 if len(batch_orders) = 500: cursor.executemany(INSERT INTO orders (user_id, order_no, total_amount, status, created_at) VALUES (%s, %s, %s, %s, %s), batch_orders) cursor.executemany(INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (%s, %s, %s, %s), batch_items) conn.commit() batch_orders = [] batch_items = [] print(f ...已处理 i 个订单) # 处理剩下的 if batch_orders: cursor.executemany(INSERT INTO orders (user_id, order_no, total_amount, status, created_at) VALUES (%s, %s, %s, %s, %s), batch_orders) cursor.executemany(INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (%s, %s, %s, %s), batch_items) conn.commit() conn.close() print(f 🎉 搞定！生成了 NUM_ORDERS 个订单，包含多种商品组合。)if __name__ == __main__: init_db() generate_data() 函数Mysql提供了很多类似于编程语言的函数，进来一堆行，吐出一个值 函数名 类型 作用 应用场景 COUNT() 聚合 数数 统计今天有多少人注册：COUNT(id) SUM() 聚合 求和 算出今天的总营业额：SUM(total_amount) AVG() 聚合 平均值 算出客单价（平均每单多少钱）：AVG(total_amount) MAX() 聚合 最大值 找出最贵的商品价格：MAX(price) MIN() 聚合 最小值 找出库存最少的商品：MIN(stock) GROUP_CONCAT() 聚合 拼接结果 把一个订单买的所有商品名拼成一行显示：薯片,可乐,辣条 NOW() 时间 当前时间 插入订单时，created_at 字段用的就是它 DATE_FORMAT() 时间 格式化 前端要显示 “2026年01月04日”，而不是数据库那串原本的英文格式 DATEDIFF() 时间 算天数 统计用户 “注册了多少天”：DATEDIFF(NOW(), created_at) CONCAT() 字符串 拼字符串 模糊搜索时拼 like 条件，或者把 姓+名 拼在一起 SUBSTR() 字符串 截取 手机号脱敏，只显示后四位 LENGTH() 字符串 算长度 检查用户简介是不是太长了 IFNULL() 逻辑 是不是NULL? 如果头像 URL 是 NULL，给个默认图：IFNULL(avatar, default.png) CASE WHEN 逻辑 SQL里的if-else 把状态 0/1 转换成中文 “未支付”“已支付” 下面的内容会使用到这些常用的函数，如果有用到的函数没有在这张表上显示的话，可以前往MySQL 函数 | 菜鸟教程 查看函数功能 分组和统计GROUP BY 语句根据一个或多个列对结果集进行分组。 SELECT 分组字段, 聚合函数(统计字段)FROM 表名WHERE 过滤条件 -- (可选) 在分组前过滤原始行GROUP BY 分组字段 -- 核心：按什么来分组HAVING 聚合后的过滤条件 -- (可选) 在分组后过滤统计结果ORDER BY 排序字段; -- (可选) 排序 使用GROUP BY分组举个简单的例子，比如我想查看mall_db_simple数据库里，products表里有多少种商品类型 select category from products group by category; 这样就会输出 +----------+| category |+----------+| 书籍 || 家居 || 数码 || 服装 || 零食 |+----------+5 rows in set (0.0005 sec) 配合函数使用如果我还想看每个分类有多少个，使用上面提到的COUNT()函数来获取个数 select category,count(category) from products group by category; 这样就会输出 +----------+-----------------+| category | count(category) |+----------+-----------------+| 书籍 | 4 || 家居 | 14 || 数码 | 8 || 服装 | 15 || 零食 | 9 |+----------+-----------------+5 rows in set (0.0009 sec) 返回的的表个数列会使用sql语句里写的内容，可以使用 AS 关键字来给这个列取个名字 select category,count(category) as category_count from products group by category; 这样列 count(category) 就会被重命名为 category_count +----------+----------------+| category | category_count |+----------+----------------+| 书籍 | 4 || 家居 | 14 || 数码 | 8 || 服装 | 15 || 零食 | 9 |+----------+----------------+5 rows in set (0.0003 sec) 使用HAVING对分组之后的结果再过滤比如我要列出个数小于10的商品，看看我商城网站上还有哪些商品比较缺 select category,count(category) as category_count from products group by category having category_count 10; 这样就只会输出商品类别小于10的商品种类 +----------+----------------+| category | category_count |+----------+----------------+| 书籍 | 4 || 数码 | 8 || 零食 | 9 |+----------+----------------+3 rows in set (0.0042 sec) HAVING和WHERE的区别？WHERE：在分组之前过滤。比如：我只统计“已支付”订单的金额。 HAVING：在分组之后过滤统计结果。比如：我只看“消费总额超过1000元”的大客户。 上面那个指令，如果把having移动到where作为条件就会 select category,count(category) as category_count from products where category_count 10 group by category ; 报错 ERROR: 1054 (42S22): Unknown column category_count in where clause WHERE会找不到分组后的这一个列 多表查询在那个py生成的数据库里，为了不让数据冗余，我把数据拆分到了不同的表里（用户一张表、订单一张表）。多表查询就是通过一个 “关联字段”，把这些表像拼图一样临时拼起来。就是多表查询 使用JOIN进行多表查询在 MySQL 中，最常用的多表查询方式是 JOIN。 查询类型 名字 效果 业务场景 INNER JOIN 内连接 只显示两边都能对上的数据 查出那些“确实下过单”的用户和订单 LEFT JOIN 左连接 左表全保留，右表没对上的显示 NULL 查出“所有用户”，包括那些还没买过东西的 RIGHT JOIN 右连接 右表全保留（很少用，通常用 LEFT JOIN 代替） - 使用内连接比如我要找到每个订单的买家和买家的手机号 select users.username,users.phone,orders.order_no,orders.total_amount from users inner join orders on users.id = orders.user_id order by users.username; 也可以使用AS来方便写sql语句，两者执行结果是一样的。我加了ORDER BY来用名字排序 SELECT u.username, u.phone, o.order_no, o.total_amountFROM users AS u INNER JOIN orders AS o ON u.id = o.user_idORDER BY u.username; 这样就会输出 +----------+-------------+------------------+--------------+| username | phone | order_no | total_amount |+----------+-------------+------------------+--------------+| 丁宁 | 13473076571 | ORD2025092300097 | 13104.00 || 丁宁 | 13473076571 | ORD2025040100039 | 8057.00 || 丁宁 | 13473076571 | ORD2025040800086 | 129.00 || 何宁 | 14796476245 | ORD2025030500020 | 13788.00 |....省略若干 使用左连接比如我要搞一个富豪榜，按照消费额度大小搞一个不漏掉没有下过单的人的全排名。 使用下面的sql语句 SELECT u.username, SUM(o.total_amount) as moneyFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idORDER BY money DESC; 这样执行就会报错 ERROR: 1140 (42000): In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column mall_db_simple.u.username; this is incompatible with sql_mode=only_full_group_by 报错信息里的 only_full_group_by 就是：“既然你用了聚合函数，那你必须告诉我，那些没被聚合的字段该按什么规则排列？” u.username：这个字段，它想把表里所有的用户名都列出来（假设有 100 行）。 SUM(o.total_amount)：这是一个聚合函数，它的目的是把所有的钱加起来，只吐出一个值（1 行）。 让数据库在第一列显示 100 个名字，但在第二列只显示 1 个总金额。 那这 1 个总金额，到底是对齐第一个人？还是最后一个人？还是平均分给所有人？数据库没法对齐 使用 GROUP BY 来按人分组，算出每个人的金额 SELECT u.username, SUM(o.total_amount) as moneyFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.usernameORDER BY money DESC; 这样就能正常输出 +----------+----------+| username | money |+----------+----------+| 胡玉 | 22626.00 || 周龙 | 21825.00 || 丁宁 | 21290.00 |...省略若干行...| 吉桂芝 | NULL || 艾静 | NULL || 程帅 | NULL |+----------+----------+193 rows in set (0.0031 sec) 没下过单的money列就会是NULL，我想把它改成0，使用IFNULL函数 SELECT u.username, IFNULL(SUM(o.total_amount),0) as moneyFROM users AS uLEFT JOIN orders AS o ON u.id = o.user_idGROUP BY u.usernameORDER BY money DESC; 这样看着就舒服多了 +----------+----------+| username | money |+----------+----------+| 胡玉 | 22626.00 || 周龙 | 21825.00 || 丁宁 | 21290.00 |...省略若干行...| 吉桂芝 | 0.00 || 艾静 | 0.00 || 程帅 | 0.00 |+----------+----------+193 rows in set (0.0023 sec) 使用子查询进行多表查询先查出一个结果，再把这个结果作为条件传给下一个查询 比如我想找出那个单笔订单花了最多钱的用户，就是分成两个查询 1.orders表里找到单笔金额最大的userid 2.根据找到的userid在users表里找到用户信息 SELECT * FROM users WHERE id = (SELECT user_id FROM orders ORDER BY total_amount DESC LIMIT 1); 这样就能输出 +-----+----------+-----------------+-------------+--------+---------------------+| id | username | email | phone | city | created_at |+-----+----------+-----------------+-------------+--------+---------------------+| 100 | 周龙 | vyu@example.net | 18958822331 | 阜新县 | 2001-07-10 10:29:42 |+-----+----------+-----------------+-------------+--------+---------------------+1 row in set (0.0005 sec) 如果要把上面的富豪榜改成子查询 SELECT u.username, (SELECT IFNULL(SUM(orders.total_amount), 0) FROM orders WHERE orders.user_id = u.id) AS moneyFROM users AS u ORDER BY money DESC; 效果是一样的 索引如果把数据库比作一本《新华字典》，那“索引”就是字典前面的拼音检索表。 没索引（全表扫描 Full Table Scan）：假设要查“字”这个字，但字典没有目录。你只能从第一页开始，一页一页往后翻，直到翻到为止。如果字典有 1000 页，最坏情况你要翻 1000 次。 效率：极低 O(n)。 有索引（Index）：先看前面的拼音目录，找到 zi 在第 500 页。直接翻到第 500 页。 效率：极高 O(log n)（因为 MySQL 底层用的是 B+树 结构，类似二分查找）。核心作用：以空间换时间。索引是一个独立的文件，占用硬盘空间，但能让查询速度提升百倍千倍。 其实那个python在创建数据表的时候，每个表创建了一个主键。 MySQL localhost:3306 mall_db_simple SQL show index from users;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| users | 0 | PRIMARY | 1 | id | A | 2000000 | NULL | NULL | | BTREE | | |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.0011 sec) 而主键是被Mysql默认作为一个索引 主键索引有什么用？定位一行数据比如这样的一条sql SELECT * FROM orders WHERE id = 10086; 这不是“查条件”，是“我知道你是谁，直接把你拎出来”。 不扫表，不比对，直接在 B+Tree 上精准定位 复杂度是 O(log n)，而不是 O(n)。 决定数据在磁盘上的物理顺序在 InnoDB 里，表中的每一行，是按主键顺序排在一起存的 id INT AUTO_INCREMENT PRIMARY KEY 意味着，id 小的在前，id 大的在后，数据页顺着排 如果要执行这样的查询 SELECT * FROM orders WHERE id BETWEEN 100 AND 200; 数据就在磁盘上连着，一页一页顺着就读下去了 并且这样join的也快，只要 join 的是主键 普通索引的“最终落脚点”在 InnoDB 里：普通索引 ≠ 指向行数据，而是普通索引 → 指向主键 普通索引节点里存的是：索引值 + 主键值 回表？什么是回表比如有这么一张表 users( id INT PRIMARY KEY, username VARCHAR(50), email VARCHAR(50), balance DECIMAL)INDEX idx_email(email) 执行这样的查询 SELECT * FROM users WHERE email = a@b.com; 实际在Mysql里是这样的： 先在idx_email里，根据 a@b.com 找到 id=100这里只有email和id，没有balance和username 然后再用id找到这一行的数据，这一步就是回表 从普通索引 → 回到主键索引 → 拿整行数据 什么时候会发生回表像这样 SELECT * FROM users WHERE email = a@b.com; 用了普通索引，但是要列里所有数据，索引里没有这么多列就会回表 但是如果是这样 SELECT email FROM users WHERE email = a@b.com;或者SELECT email, id FROM users WHERE email = a@b.com; 这样就不会回表，因为要找的东西在索引里就有了 索引的使用还是那个py，把用户改成两百万个，运行Py后执行下面的查询 SELECT * FROM users WHERE username LIKE 哈基; 运行后是找不到这个数据的，这个正常，主要看找数据花了多久？ MySQL localhost:3306 mall_db_simple SQL SELECT * FROM users WHERE username LIKE 哈基;Empty set (0.2233 sec) 0.22秒，看起来不多，纯粹是因为我的电脑硬件（CPU、内存、SSD）太强了，把“笨重”的 SQL 硬扛下来了。如果是要面对大量并发查询，每次全表扫描就太慢了 users 表里现在只有主键索引（PRIMARY），但查询条件是 WHERE username LIKE ...。因为 username 没有索引，MySQL 其实做了一次“全表扫描”。 执行下面的SQL看看是怎么查询的 EXPLAIN SELECT * FROM users WHERE username LIKE 哈基; 运行输出: +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | users | NULL | ALL | NULL | NULL | NULL | NULL | 2000000 | 11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+1 row in set, 1 warning (0.0010 sec)Note (code 1003): /* select#1 */ select `mall_db_simple`.`users`.`id` AS `id`,`mall_db_simple`.`users`.`username` AS `username`,`mall_db_simple`.`users`.`email` AS `email`,`mall_db_simple`.`users`.`phone` AS `phone`,`mall_db_simple`.`users`.`city` AS `city`,`mall_db_simple`.`users`.`created_at` AS `created_at` from `mall_db_simple`.`users` where (`mall_db_simple`.`users`.`username` like 哈基) 可以看到type列是ALL(代表全表扫描，最烂的情况) ，rows列是2000000遍历了两百万行 创建和使用索引创建索引的SQL语句是 CREATE INDEX 索引名 ON 表名(字段名); 在这里就是 CREATE INDEX idx_username ON users(username); 执行后再次运行上面那个查询，可以看到是瞬间给出结果了 MySQL localhost:3306 mall_db_simple SQL SELECT * FROM users WHERE username LIKE 哈基;Empty set (0.0004 sec) 只用了0.0004秒，现在再看看Mysql是怎么查询的 MySQL localhost:3306 mall_db_simple SQL EXPLAIN SELECT * FROM users WHERE username LIKE 哈基;+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | users | NULL | range | idx_username | idx_username | 203 | NULL | 1 | 100 | Using index condition |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.0004 sec)Note (code 1003): /* select#1 */ select `mall_db_simple`.`users`.`id` AS `id`,`mall_db_simple`.`users`.`username` AS `username`,`mall_db_simple`.`users`.`email` AS `email`,`mall_db_simple`.`users`.`phone` AS `phone`,`mall_db_simple`.`users`.`city` AS `city`,`mall_db_simple`.`users`.`created_at` AS `created_at` from `mall_db_simple`.`users` where (`mall_db_simple`.`users`.`username` like 哈基) 看rows列变成了1，就是说明只需要扫 1 条索引记录，就能命中 删除索引DROP INDEX 索引名 ON 表名; 如果索引建错了，或者没用上，要删掉（因为索引会拖慢写入速度）。就用上面的命令。我不演示了 索引的副作用既然这么好，为啥不给所有字段都加？给 username, phone, email, address 全加上索引，岂不是起飞？ 拖慢写入（INSERTUPDATEDELETE）： 往书里写一行内容（INSERT），不仅要往正文里写，还得去改目录（维护索引树）。索引越多，改目录越慢。 对于写多读少的系统（比如日志系统），索引要慎用。 占用磁盘空间： 索引也是文件，也是要存硬盘的。数据量大时，索引可能比数据本身还大。 LIKE的坑在刚刚的SQL里使用了LIKE但是没有加百分号。也就是说其实还是使用的精确匹配 精确匹配前缀匹配（索引生效 ） EXPLAIN SELECT * FROM users WHERE username LIKE 哈基%; 结果：type 是 range 或 ref。索引生效了！因为目录是按拼音排的，MySQL 知道“哈”在前面的几页。 +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | users | NULL | range | idx_username | idx_username | 203 | NULL | 1 | 100 | Using index condition |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.0009 sec)Note (code 1003): /* select#1 */ select `mall_db_simple`.`users`.`id` AS `id`,`mall_db_simple`.`users`.`username` AS `username`,`mall_db_simple`.`users`.`email` AS `email`,`mall_db_simple`.`users`.`phone` AS `phone`,`mall_db_simple`.`users`.`city` AS `city`,`mall_db_simple`.`users`.`created_at` AS `created_at` from `mall_db_simple`.`users` where (`mall_db_simple`.`users`.`username` like 哈基%) 左模糊匹配（索引失效 ） -- 找名字里以“米”结尾的人（比如哈基米、小米）EXPLAIN SELECT * FROM users WHERE username LIKE %米; 结果：type 又是 ALL 了！ 查字典的时候，如果只知道这就字“结尾是米”，没法用拼音目录查，只能把整本字典翻一遍。 +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | users | NULL | ALL | NULL | NULL | NULL | NULL | 2000000 | 11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+1 row in set, 1 warning (0.0003 sec)Note (code 1003): /* select#1 */ select `mall_db_simple`.`users`.`id` AS `id`,`mall_db_simple`.`users`.`username` AS `username`,`mall_db_simple`.`users`.`email` AS `email`,`mall_db_simple`.`users`.`phone` AS `phone`,`mall_db_simple`.`users`.`city` AS `city`,`mall_db_simple`.`users`.`created_at` AS `created_at` from `mall_db_simple`.`users` where (`mall_db_simple`.`users`.`username` like %米) 如果我想倒着查也能瞬间给出结果？使用虚拟列功能 -- 1. 给表加一个虚拟列，内容是 username 的倒序ALTER TABLE users ADD reverse_username VARCHAR(50) GENERATED ALWAYS AS (REVERSE(username));-- 2. 给这个倒序列加索引CREATE INDEX idx_reverse_username ON users(reverse_username); 如果使用的是Windows的phpstudy中的Mysql5.7，默认不会是InnoDB，在执行第二步就会报错 ERROR: 1478 (HY000): Table storage engine MyISAM does not support the create option Index on virtual generated column 这时候使用ALTER命令修改存储引擎为InnoDB ALTER TABLE users ENGINE=InnoDB; 再执行第二步就正常了，现在看看左模糊匹配效果，不过得在username的倒序列里查找 MySQL localhost:3306 mall_db_simple SQL SELECT * FROM users WHERE reverse_username LIKE 米%;Empty set (0.0015 sec)MySQL localhost:3306 mall_db_simple SQL EXPLAIN SELECT * FROM users WHERE reverse_username LIKE 米%;+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+| 1 | SIMPLE | users | NULL | range | idx_reverse_username | idx_reverse_username | 203 | NULL | 1 | 100 | Using where |+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.0008 sec)Note (code 1003): /* select#1 */ select `mall_db_simple`.`users`.`id` AS `id`,`mall_db_simple`.`users`.`username` AS `username`,`mall_db_simple`.`users`.`email` AS `email`,`mall_db_simple`.`users`.`phone` AS `phone`,`mall_db_simple`.`users`.`city` AS `city`,`mall_db_simple`.`users`.`created_at` AS `created_at`,`mall_db_simple`.`users`.`reverse_username` AS `reverse_username` from `mall_db_simple`.`users` where (`mall_db_simple`.`users`.`reverse_username` like 米%) 也是秒出。也只用扫描一条记录 事务事务是不支持MyISAM存储引擎的 事务是把一组SQL语句打包成一个整体，在这组SQL语句的执行过程中，要么全部成功，要么全部失败。这组SQL语句可以是一条也可以是多条。 事务的八股: A (Atomicity) 原子性： 事务中的所有操作就是一个不可分割的整体，像原子一样。这些操作，要么全部成功，要么全部失败。数据库会记录事务执行前的数据状态，一旦事务执行过程出现失败，就会回滚到原来的初始状态。 原理：靠 Undo Log 实现（万一失败了，根据日志把数据改回去）。 C (Consistency) 一致性： 事务执行前后，事务的完整性不会被破坏。事务执行完成之后，保证数据正确并且符合预期。 I (Isolation) 隔离性： 数据库允许多个并发事务同时对数据进行修改和读写，隔离性可以保证多个事务并发执行，并且不相互干扰。 原理：靠 锁 (Lock) 和 MVCC (多版本并发控制) 实现。 D (Durability) 持久性： 只要 COMMIT 了，哪怕下一秒服务器爆炸，电线被挖断，数据也不能丢。 原理：靠 Redo Log 实现（先写日志再写磁盘）。 事务指令 指令 作用 START TRANSACTION (或 BEGIN) 开启事务。告诉 MySQL：“从这一行开始，后面的操作先别真写入硬盘，先记在小本本上。” COMMIT 提交。告诉 MySQL：“刚才的操作都确认无误，全部生效，写入硬盘！” ROLLBACK 回滚。告诉 MySQL：“出事了！刚才的操作全部作废，撤销到开启事务之前的状态！” savepoint 设置一个存档。告诉Mysql在这里保存一个状态。如果回滚的话可以选择回滚到这里 注意：事务是有适用范围的 能回滚的（DML - Data Manipulation Language）： INSERT（增） UPDATE（改） DELETE（删数据） 不能回滚且会强制提交的（DDL - Data Definition Language）： CREATE（建表库） DROP（删表库） ALTER（改字段） TRUNCATE（清空表） 比如下面这个例子: MySQL localhost:3306 mall_db_simple SQL start transaction;Query OK, 0 rows affected (0.0001 sec)MySQL localhost:3306 mall_db_simple ★ SQL show databases;+--------------------+| Database |+--------------------+| information_schema || mall_db_simple || mysql || performance_schema || sys |+--------------------+5 rows in set (0.0008 sec)MySQL localhost:3306 mall_db_simple ★ SQL drop database mall_db_simple;Query OK, 4 rows affected (0.0082 sec)MySQL localhost:3306 mall_db_simple SQL rollback;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple SQL show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.0006 sec) Mysql在执行DDL指令前，不会管前面有没有start transaction;都会先执行一个COMMIT，然后再会执行DDL指令。执行完DDL后再会执行一个COMMIT。后续的rollback滚不回来 DELETE和TRUNCATE的区别 想清空一张表，且希望可以回滚： 用 DELETE FROM users; 这是 DML，速度慢（一行行删），但可以 ROLLBACK。 想清空一张表，不留后路： 用 TRUNCATE TABLE users; 这是 DDL，速度快（直接把表文件扔了重新建一个），但ROLLBACK不回来。 开始事务之前库存是怎么被下单操作搞乱的？先看看id为1的商品有多少个库存 SELECT id, stock FROM products WHERE id = 1; 执行得到结果剩余100个 MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 100 |+----+-------+1 row in set (0.0003 sec) 此时一位正常用户进来买了一个id为1的商品 UPDATE products SET stock = stock - 1 WHERE id = 1; 这时候库存还剩99个 MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 99 |+----+-------+1 row in set (0.0004 sec) sec) 然后一位测试进来买了-1个id为1的商品 UPDATE products SET stock = stock - (-1) WHERE id = 1; 库存增加了！ MySQL localhost:3306 mall_db_simple SQL UPDATE products SET stock = stock - (-1) WHERE id = 1;Query OK, 1 row affected (0.0010 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 100 |+----+-------+1 row in set (0.0004 sec) 然后这位测试买了9999个商品 UPDATE products SET stock = stock - 9999 WHERE id = 1; 然后他买到了9999个商品并且把库存干成负数了，商城超卖了 MySQL localhost:3306 mall_db_simple SQL UPDATE products SET stock = stock - 9999 WHERE id = 1;Query OK, 1 row affected (0.0010 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | -9899 |+----+-------+1 row in set (0.0004 sec) 解决方法利用UPDATE 语句的原子性，把“判断”逻辑直接写在 SQL 里。 UPDATE products SET stock = stock - 购买数量WHERE id = 1 AND stock = 购买数量; 这样的执行效果是 MySQL localhost:3306 mall_db_simple SQL UPDATE products SET stock = stock - 9999 WHERE id = 1 AND stock = 9999;Query OK, 0 rows affected (0.0009 sec)Rows matched: 0 Changed: 0 Warnings: 0MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 100 |+----+-------+1 row in set (0.0003 sec) 效果： 库存够：MySQL 找到这行数据，且条件满足，执行扣减。返回 Rows matched: 1, Changed: 1。后端看到影响行数为 1，判定购买成功。 库存不够（比如库存是 100）：MySQL 扫这行数据，发现 stock = 9991 不成立。直接放弃修改。返回 Rows matched: 0, Changed: 0。后端看到影响行数为 0，判定库存不足，下单失败。 同样的方法解决买了-1个商品导致库存增加的问题，再添加一个AND判断逻辑 UPDATE products SET stock = stock - 购买数量WHERE id = 1 AND stock = 购买数量AND 购买数量 0; 这样当购买数量为-1的时候 MySQL localhost:3306 mall_db_simple SQL UPDATE products SET stock = stock - (-1) WHERE id = 1 AND stock = (-1) AND (-1) 0;Query OK, 0 rows affected (0.0010 sec)Rows matched: 0 Changed: 0 Warnings: 0MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 100 |+----+-------+1 row in set (0.0004 sec) 同样，0行被match，0行被change 没用的解决方法后端检测库存数量是否充足，再执行扣库存？ 假设库存只有 1 个。User A和User B同时点击购买。后端代码（错误示范）： # 1. 先查库存current_stock = db.query(SELECT stock FROM products WHERE id=1)# 2. 判断充足if current_stock 0: # 3. 扣库存 db.exec(UPDATE products SET stock = stock - 1 WHERE id=1) return 购买成功else: return 库存不足 超卖过程： 时刻 0.01s：A 查库存，是 1。 时刻 0.01s：B 查库存，也是 1（因为 A 还没扣呢）。 时刻 0.02s：A 判断 1 0，通过。 时刻 0.02s：B 判断 1 0，通过。 时刻 0.03s：A 扣减，库存变 0。 时刻 0.03s：B 扣减，库存变 -1。结果：卖出了 2 个手机，实际上仓库只有 1 个。超卖了。 如果要求库存不能为负数？在MySQL 8.0.16+使用Check约束是可行的 ALTER TABLE productsADD CONSTRAINT chk_stock_non_negativeCHECK (stock = 0); 之后再尝试扣除超过库存的数的时候 UPDATE products SET stock = stock - 9999 WHERE id = 1; 就会直接报错 ERROR 3819 (HY000): Check constraint chk_stock_non_negative is violated 但是要注意，CHECK 是兜底，不是主流程。因为报错成本高，不方便区分“库存不足 vs 其他错误”，而且在高并发下，异常比 affected_rows 慢 如果使用UNSIGNED？表面看起来可行，但不推荐 在某些版本 SQL_MODE 下：要么报错，要么发生隐式类型转换，行为不稳定 UNSIGNED 解决的是“值域”，不是并发逻辑 总之在后端逻辑和SQL语句的编写中，对于凡是能参与加减乘除的字段，都假设有人会传负数、零、极大值 使用事务回滚的使用MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 99 |+----+-------+1 row in set (0.0039 sec)MySQL localhost:3306 mall_db_simple SQL START TRANSACTION;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL UPDATE products SET stock = stock - 1 WHERE id = 1;Query OK, 1 row affected (0.0015 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 98 |+----+-------+1 row in set (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL ROLLBACK;Query OK, 0 rows affected (0.0072 sec)MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 99 |+----+-------+1 row in set (0.0003 sec) 可见，开始之前，id为1的商品库存99个。然后启动事务，将商品数量扣除1个后，再次查看商品数量已经变成98个了。然后使用回滚。商品数量没有变化 提交的使用MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 99 |+----+-------+1 row in set (0.0025 sec)MySQL localhost:3306 mall_db_simple SQL begin;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL UPDATE products SET stock = stock - 2 WHERE id = 1;Query OK, 1 row affected (0.0005 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 97 |+----+-------+1 row in set (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL commit;Query OK, 0 rows affected (0.0045 sec)MySQL localhost:3306 mall_db_simple SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 97 |+----+-------+1 row in set (0.0003 sec) 可见，开始之前，id为1的商品库存99个。然后启动事务，将商品数量扣除2个后，再次查看商品数量已经变成97个了。使用commit提交后，事务结束。商品库存扣除 保存点的使用在同一事务中，保存点名称是唯一的。如果设置相同名称的保存点名称，后设置的保存点会覆盖先设置的 看下面的例子 MySQL localhost:3306 mall_db_simple SQL begin;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 100 |+----+-------+1 row in set (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL UPDATE products SET stock = stock - 10 WHERE id = 1;Query OK, 1 row affected (0.0004 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 90 |+----+-------+1 row in set (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL savepoint koukuncun1;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL UPDATE products SET stock = stock - 20 WHERE id = 1;Query OK, 1 row affected (0.0003 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 70 |+----+-------+1 row in set (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL savepoint koukuncun2;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL rollback to koukuncun1;Query OK, 0 rows affected (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 90 |+----+-------+1 row in set (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL rollback to koukuncun2;ERROR: 1305 (42000): SAVEPOINT koukuncun2 does not existMySQL localhost:3306 mall_db_simple ★ SQL release savepoint koukuncun1;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL UPDATE products SET stock = stock - 20 WHERE id = 1;Query OK, 1 row affected (0.0004 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL localhost:3306 mall_db_simple ★ SQL SELECT id, stock FROM products WHERE id = 1;+----+-------+| id | stock |+----+-------+| 1 | 70 |+----+-------+1 row in set (0.0003 sec)MySQL localhost:3306 mall_db_simple ★ SQL rollback to koukuncun1;ERROR: 1305 (42000): SAVEPOINT koukuncun1 does not exist 一个会话里可以设置多个保存点。并且可以通过rollback to 保存点回到保存点。 但是，保存点不是变量。就比如上面的例子，创建了保存点koukuncun1后又创建了保存点koukuncun2。然后直接回滚到了koukuncun1。这时候就不能再回滚到koukuncun2了，因为koukuncun2对于koukuncun1来说是未来发生的。也可以使用release savepoint 保存点指令来释放保存点。释放后的保存点同样不能再回滚。 自动提交？手动提交？ 什么是自动提交（默认）？敲一行 SQL，回车，MySQL 立刻把它存进硬盘（Commit）。 状态：autocommit = 1 (开启) 场景：平时在命令行里敲 UPDATE ...，没敲 COMMIT 数据也改了，就是因为这个。 什么是手动提交？需要显式地告诉 MySQL：“我要开始记账了”和“我记完账了”。 状态：autocommit = 0 (关闭) 场景： 方法 A（推荐，临时手动）：输入 START TRANSACTION。此时 autocommit 暂时失效，直到你敲 COMMIT 或 ROLLBACK。 方法 B（全局手动，不推荐）：执行 SET autocommit = 0;。这很危险！如果忘了敲 COMMIT，做了一天的操作，关掉窗口后全都会丢。 通过下面的命令查看当前状态 SELECT @@autocommit; 一般都是默认开启了自动提交 MySQL localhost:3306 mall_db_simple SQL SELECT @@autocommit;+--------------+| @@autocommit |+--------------+| 1 |+--------------+1 row in set (0.0001 sec) 事务的隔离级别MySQL 提供了 4 种级别，安全性从低到高，性能从高到低： 级别 英文名 绰号 特点 会发生什么？ 1 Read Uncommitted 读未提交 裸奔 别人还没 Commit 的数据就能看见。（脏读、不可重复读、幻读） 2 Read Committed 读已提交 (RC) 半隔离 别人 Commit 了，才能看见。（幻读和不可重复读） 3 Repeatable Read 可重复读 (RR) 照骗 MySQL 默认 事务一开始，就拍个照。不管别人怎么改，看到的永远是开始时的样子。 4 Serializable 串行化 排队 只要我没搞完，别人连查都不准查。慢到令人发指。 默认可重复读的场景场景：（窗口 A）在查账，（窗口 B）在改数据。 窗口 A：开启事务，先查一下库存。 START TRANSACTION;SELECT stock FROM products WHERE id = 1; 窗口 B：开启事务，卖掉 50 个 UPDATE products SET stock = 50 WHERE id = 1; 窗口 A：再次查询库存。 SELECT stock FROM products WHERE id = 1; 结果：还是 100！ (哪怕窗口 B 已经改成 50 了) 原因：这就是 Repeatable Read。在开启事务的那一刻，MySQL 给他生成了一个“快照”。只要不结束事务，外面的世界天崩地裂，他看到的永远是 100。 窗口 A：结束查账。 COMMIT;SELECT stock FROM products WHERE id = 1;--结果：50 如果窗口A要获取实时数据，就使用 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; 事务并发执行可能引发的问题 脏读 (Dirty Read)： 现象：A 读到了 B 还没提交的数据。结果 B 回滚了，A 读到的是假数据。 谁有这毛病：Read Uncommitted。 不可重复读 (Non-repeatable Read)： 现象：A 第一次读是 100，B 改成 50 提交了，A 第二次读变成 50。A 懵了：“怎么一会儿一个样？” 谁有这毛病：Read Committed 。 幻读 (Phantom Read)： 现象：A 查所有订单，发现有 5 个。B 偷偷插入了一个新订单。A 准备修改这 5 个订单，结果发现数据库里有 6 个订单受影响。A 觉得出现了幻觉。 在大部分情况下保持默认 (Repeatable Read) 就行 MySQL 的默认设置已经非常优秀，能避免大多数并发坑。 只有在极少数对“实时性”要求极高，且为了减少死锁的场景下（比如 12306 抢票），才会去考虑改为 RC。不过上面的那些内容也是面试狗官爱问的。 间隙锁间隙锁 (Gap Lock) 是 MySQL (InnoDB) 里的特性，也是只有在 RR（可重复读）隔离级别下才会生效的特殊锁机制。 不需要专门写 SQL 去调用它。只要隔离级别是默认的 Repeatable Read (RR)，并且执行了范围查询的加锁操作，MySQL 就会自动触发间隙锁。 如果没有间隙锁场景：事务A要查 ID 10 的所有订单。目前只有 ID11, ID13 两条。 动作：事务A执行 SELECT * FROM orders WHERE id 10 FOR UPDATE;（锁住查到的数据）。 漏洞：如果没有间隙锁，只锁住了 11 和 13。这时候事务B偷偷插入了一条 ID12 的数据。 结果：事务A还没提交事务，再查一次，发现突然多出来一个 12！见鬼了（幻读）。间隙锁的作用：事务A不仅把 11 和 13 锁住，还拉起了警戒线——“把 11 和 13 中间的空位、13 后面的空位全封死！谁也不准往里插数据！” 间隙锁的工作首先先创建一个很简单的表 CREATE TABLE gap_test ( id INT PRIMARY KEY) ENGINE=InnoDB;INSERT INTO gap_test VALUES (1), (5), (10); 在其中一个窗口启动事务查询里面的数据 MySQL localhost:3306 mall_db_simple SQL START TRANSACTION;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 mall_db_simple ★ SQL SELECT * FROM gap_test WHERE id 1 AND id 10 FOR UPDATE;+----+| id |+----+| 5 |+----+1 row in set (0.0004 sec) 这时候再到另一个窗口启动事务，并尝试往这些“空位”里插数据。 MySQL localhost:3306 SQL START TRANSACTION;Query OK, 0 rows affected (0.0002 sec)MySQL localhost:3306 ★ SQL use mall_db_simple;Default schema set to `mall_db_simple`.Fetching global names, object names from `mall_db_simple` for auto-completion... Press ^C to stop.MySQL localhost:3306 mall_db_simple ★ SQL INSERT INTO gap_test VALUES (2); 卡在这里不动了，因为在第一个窗口 MySQL 会自动加上间隙锁，锁住 (1, 5) 和 (5, 10) 这两个区间 间隙锁导致的死锁 A 用户想注册名字叫“哈基米”，由于并发逻辑，他先用 SELECT * FROM users WHERE name = 哈基米 FOR UPDATE 查一下有没有。 假设数据库里没这人。MySQL 加上了间隙锁（锁住了这一片不存在的区域）。 B 用户同时也想注册“哈基米”，也执行了同样的 SQL。 间隙锁和间隙锁之间是不冲突的！B 用户也加上了间隙锁。 A 用户执行 INSERT ... 哈基米。 崩了：A 被 B 的间隙锁挡住了。 B 用户执行 INSERT ... 哈基米。 崩了：B 被 A 的间隙锁挡住了。 MySQL 报错 “Deadlock found”，其中一个用户直接报错退出。 如果不需要极其严格的防幻读（大多数互联网业务都不需要），可以选择把隔离级别降级为 RC (Read Committed)。在 RC 级别下，间隙锁会自动关闭。这样能大大减少死锁，提升并发度。","tags":["notebook","Mysql","Database"]},{"title":"Mysql攻略-安装使用到基础的增删改查","path":"/2026/01/02/mysql-quick/","content":"看完本文你将速通Mysql基本操作和最常用的增删改查。看完你就是sqlboy 如果你再看完 Mysql攻略-进阶功能 这篇文章，你将速通：连表查询，分组与统计，子查询，事务，索引，窗口函数，悲观锁，处理 JSON 数据，复杂逻辑处理(if else)，性能分析，存储过程与触发器等等高级功能你会瞬间变成Mysql高手 通过Docker安装和使用Mysql安装和启动这里我用docker了，因为ubuntu的apt源里面没有mysql，安装的话随意了喜欢哪种方式用那种方式 cloudyou@cloudyou-i1025P:~$ docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysqlDigest: sha256:5ca0a273ed28c73acaef91da8bf1eca3711bee94bce4c378d42846375e645a72Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latestcloudyou@cloudyou-i1025P:~$ docker run -d \\ --name mysql-test \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -p 3306:3306 \\ mysql1ca08ce15790ffddff0440424b3c589a68f5c09aac5110632f9959a1485e8cloudyou@cloudyou-i1025P:~$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1ca08ce15790 mysql docker-entrypoint.s… About a minute ago Up About a minute 0.0.0.0:3306-3306/tcp, [::]:3306-3306/tcp, 33060/tcp mysql-testdcc 用先把mysql pull下来后，使用了docker run来运行。 -d：后台运行，不霸占终端 --name mysql-test：给容器起个名字，方便后面折腾 MYSQL_ROOT_PASSWORD=123456：指定Mysql的root用户密码 -p 3306:3306：宿主机 ↔ 容器端口打通 mysql：刚 pull 下来的那个镜像 现在使用docker ps就可以看到mysql的容器在运行了 停止删除这个容器使用docker stop 容器名 或者 docker kill 容器名 cloudyou@cloudyou-i1025P:~$ docker stop mysql-testmysql-testcloudyou@cloudyou-i1025P:~$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScloudyou@cloudyou-i1025P:~$ 可以看到没东西了 删除的话同理，使用 docker rm 容器名 就行，这里不演示了 exec进入sql shell使用 docker exec -it mysql-test mysql -uroot -p -it 其实是两个参数的合体写法： -i interactive（保持标准输入），让键盘输入能传进容器 -t tty（分配一个终端），给一个“像终端一样”的交互界面 cloudyou@cloudyou-i1025P:~$ docker exec -it mysql-test mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 10Server version: 9.5.0 MySQL Community Server - GPLCopyright (c) 2000, 2025, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type help; or \\h for help. Type \\c to clear the current input statement.mysql 使用Mysql Shell连接到数据库使用 \\connect 用户名@数据库地址 来连接到数据库 Mysql Shell是支持Python js 和 sql 的，如果不是SQL那要先 \\sql 切换到sql语句 MySQL SQL \\connect root@192.168.31.238Creating a session to root@192.168.31.238Please provide the password for root@192.168.31.238: ******Save password for root@192.168.31.238? [Y]es/[N]o/Ne[v]er (default No): YFetching global names for auto-completion... Press ^C to stop.Your MySQL connection id is 9Server version: 9.5.0 MySQL Community Server - GPLNo default schema selected; type \\use schema to set one.MySQL 192.168.31.238:3306 ssl SQL 上手之前自带的数据库干嘛用的？进入sql shell后，使用show databases;可以看到自带了4个数据库 MySQL 192.168.31.238:3306 ssl SQL show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.0164 sec) mysql这是最老、最重要的库。里面装的是什么？ 用户账号，密码哈希，权限，角色，grant 规则 常见表： mysql.user mysql.db mysql.tables_priv 用户能不能连、能干啥，全写在 mysql 里 information_schema这是一个只读的、虚拟的库。它不存数据，只反映“现在的状态” 比如：有哪些库，有哪些表，字段类型，索引，表大小 比如常见的 SHOW TABLES;其实等价于SELECT * FROM information_schema.tables WHERE table_schema = xxx; 他是说明现在Mysql长什么样 performance_schema这是 MySQL 的监控系统。看 SQL 慢不慢，哪些锁卡人，IO 用量，内存消耗，线程状态 慢查询、性能分析工具，背后大多在读它。 特点：数据是实时的，重启会清空，对性能有轻微影响（可配置） 它记录 MySQL“现在累不累” sys这是个“视图库”，不是原始数据。它干了啥？ 把 performance_schema 里一堆表，包装成好读的视图 总之 sys performance_schema 的精装修版 Mysql的数据类型和编程语言类似，Mysql也提供了多种数据类型 数值类型关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 类型 大小 范围（有符号） 用途 TINYINT 1 Bytes (-128，127) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) 极大整数值 FLOAT 4 Bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 单精度 浮点数值 DOUBLE 8 Bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果MD，为M+2否则为D+2 依赖于M和D的值 小数值 实际业务里常用的: TINYINT (1字节) 范围：-128 ~ 127。 场景：状态标识、布尔值。 例子：status (0待付款, 1已付款, 2已发货)，is_vip (0否, 1是)。 注意：MySQL 里没有 Boolean 类型，通常用 TINYINT(1) 来存 truefalse。 INT (4字节) 范围：±21亿。 场景：大多数表的主键 ID、库存数量、视频时长（秒）。 技巧：如果不存负数（比如库存），建议加上 UNSIGNED，范围能翻倍到 42亿。 BIGINT (8字节) 范围：极大（19位数字）。 场景：主键 ID（订单表）、视频播放量（像 YouTube 这种级别）。 警示：电商的订单号通常很长（比如雪花算法生成的 ID），INT 存不下，必须用 BIGINT。 小数部分如果和钱有关的话，不要用FLOAT DOUBLE 它们是浮点数，会有精度丢失。存 19.9，可能数据库里变成 19.900000001 或 19.89999999。 和钱相关的业务使用：DECIMAL(M, D) 它是定点数，精准存储。 场景：商品价格、钱包余额。 常用配置：DECIMAL(10, 2)。 10 表示总共 10 位数字（应对亿元级别的金额）。 2 表示小数点后保留 2 位（精确到分）。 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 类型 大小 ( bytes) 格式 用途 DATE 3 YYYY-MM-DD 日期值 TIME 3 HH:MM:SS 时间值或持续时间 YEAR 1 YYYY 年份值 DATETIME 8 YYYY-MM-DD hh:mm:ss 混合日期和时间值 TIMESTAMP 4 YYYY-MM-DD hh:mm:ss 混合日期和时间值，时间戳 DATETIME 场景：订单创建时间、用户注册时间。 优点：直观，存什么就是什么，不受时区影响 TIMESTAMP (时间戳) 场景：记录数据最后修改时间（ON UPDATE CURRENT_TIMESTAMP）。 缺点：时区转换问题，且这个数据类型有“2038年虫危机”（旧版本 MySQL 只能存到 2038 年），所以现在很多新系统倾向于用 DATETIME 或直接存 BIGINT (毫秒时间戳)。 字符串类型名字、描述、链接 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 CHAR(N) (固定长度) 场景：MD5 值、手机号、身份证号、国家代码 (‘CN’, ‘US’)。 理由：速度极快，不容易产生内存碎片。比如密码加密后固定是 32 位，就用 CHAR(32)。 VARCHAR(N) (可变长度) 场景：用户名、商品标题、视频链接 (URL)、评论。 注意：N 代表字符数（不是字节）。VARCHAR(255) 是个习惯写法，但如果标题只有 20 字，写 VARCHAR(50) 索引效率会更高一点点。 TEXT MEDIUMTEXT (大文本) 场景：商品详情页 HTML 代码、博客正文。 坑点：查询时如果没必要，千万别 SELECT * 把 TEXT 字段也查出来，非常拖慢网络传输和内存。 CHAR和VARCHAR的区别？char是个定长的，比如char(10) ,不管存几个字符，都占 10 个字符空间。没用满的部分，会用空格补齐。 varchar是动态长度的，比如varchar(10),最多 10 个字符，用多少占多少。省空间 什么时候用CHAR？ 场景 类型 UUID（32位） CHAR(32) MD5 CHAR(32) SHA1 CHAR(40) 国家代码 CHAR(2) 性别 CHAR(1) 长度永远固定的场景，用 VARCHAR 反而多此一举。 Mysql的运算符同理，Mysql也提供了用于查询的时候限定条件的运算符，这里列出些常用的 比较运算符最基础的过滤方式，用于数值或字符串的精确比较。 运算符 含义 示例 = 等于 WHERE score = 100 或 != 不等于 WHERE status != deleted 大于 小于 WHERE price 50 = = 大于等于 小于等于 WHERE age = 18 BETWEEN ... AND ... 在范围内（含边界） WHERE age BETWEEN 20 AND 30 逻辑运算符当有多个条件需要同时判断时，使用逻辑运算符进行组合。 AND：所有条件都必须满足（且）。 OR：只要满足其中一个条件即可（或）。 NOT：取反，排除符合条件的行。 示例： WHERE age 18 AND gender = female 模糊匹配与集合 LIKE：模糊查询，配合 %（任意个字符）和 _（单个字符）使用。 IN (...)：查询字段值是否在给定的集合中。 示例： WHERE city IN (北京, 上海, 广州) IS NULL：判断某个字段是否为空（注意：不能用 = NULL）。 数据库操作创建，删除，使用~~ 创建数据库使用 create 命令创建数据库 CREATE DATABASE 数据库名; 比如我创建一个哈基米数据库 MySQL 192.168.31.238:3306 ssl SQL create database Hachimi;Query OK, 1 row affected (0.1453 sec)MySQL 192.168.31.238:3306 ssl SQL show databases;+--------------------+| Database |+--------------------+| Hachimi || information_schema || mysql || performance_schema || sys |+--------------------+5 rows in set (0.0167 sec) 删除数据库使用 drop 命令删除数据，IF EXISTS 是一个可选的子句，表示如果数据库存在才执行删除操作。 DROP DATABASE database_name; -- 直接删除数据库，不检查是否存在DROP DATABASE [IF EXISTS] database_name; 把刚刚创建的哈基米数据库删除掉 MySQL 192.168.31.238:3306 ssl SQL drop database Hachimi;Query OK, 0 rows affected (0.0408 sec)MySQL 192.168.31.238:3306 ssl SQL show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.0194 sec) 使用数据库要选择要使用的数据库，使用 USE 语句 USE 数据库名; 使用数据库 Hachimi MySQL 192.168.31.238:3306 ssl SQL use Hachimi;Default schema set to `Hachimi`.Fetching global names, object names from `Hachimi` for auto-completion... Press ^C to stop.MySQL 192.168.31.238:3306 ssl Hachimi SQL 查看数据库里的表，使用 show tables; 表的操作创建表以下为创建 MySQL 数据表通用语法 CREATE TABLE [IF NOT EXISTS] 表名 ( 列名1 数据类型 , 列名2 数据类型 , ...); 比如这样创建一个用户表 CREATE TABLE IF NOT EXISTS UserData ( username VARCHAR(50), userid INT, phone VARCHAR(11), isvip TINYINT(1), passwd CHAR(32), regTime DATETIME, balance DECIMAL(10, 2)); 执行后的效果如下，使用desc 表名查看表的描述 MySQL 192.168.31.238:3306 ssl Hachimi SQL show tables;+-------------------+| Tables_in_Hachimi |+-------------------+| UserData |+-------------------+1 row in set (0.0144 sec) MySQL 192.168.31.238:3306 ssl Hachimi SQL desc UserData;+----------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+---------------+------+-----+---------+-------+| username | varchar(50) | YES | | NULL | || userid | int | YES | | NULL | || phone | varchar(11) | YES | | NULL | || isvip | tinyint(1) | YES | | NULL | || passwd | char(32) | YES | | NULL | || regTime | datetime | YES | | NULL | || balance | decimal(10,2) | YES | | NULL | |+----------+---------------+------+-----+---------+-------+7 rows in set (0.0450 sec) MySQL 192.168.31.238:3306 ssl Hachimi SQL 修改表修改列ALTER TABLE 表名 MODIFY COLUMN 列名 新的数据类型; 比如我想把username从最长50个字符改成最长30个字符 MySQL 192.168.31.238:3306 ssl Hachimi SQL ALTER TABLE UserData MODIFY COLUMN username VARCHAR(30);Query OK, 0 rows affected (0.3134 sec)Records: 0 Duplicates: 0 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL DESC UserData;+----------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+---------------+------+-----+---------+-------+| username | varchar(30) | YES | | NULL | || userid | int | YES | | NULL | || phone | varchar(11) | YES | | NULL | || isvip | tinyint(1) | YES | | NULL | || passwd | char(32) | YES | | NULL | || regTime | datetime | YES | | NULL | || balance | decimal(10,2) | YES | | NULL | |+----------+---------------+------+-----+---------+-------+7 rows in set (0.0174 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL MODIFY COLUMN不只是仅限于数据类型 数据类型 ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型; 是否允许 NULL ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型 NOT NULL; 默认值 ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型 DEFAULT CURRENT_TIMESTAMP; 长度 精度（数字、字符类型） ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型 NOT NULL; 修改列的名字ALTER TABLE 表名 RENAME COLUMN 列名 TO 新的列名; 比如我想把username改名成dickname MySQL 192.168.31.238:3306 ssl Hachimi SQL ALTER TABLE UserData RENAME COLUMN username TO dickname;Query OK, 0 rows affected (0.1856 sec)Records: 0 Duplicates: 0 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL DESC UserData;+----------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+---------------+------+-----+---------+-------+| dickname | varchar(30) | YES | | NULL | || userid | int | YES | | NULL | || phone | varchar(11) | YES | | NULL | || isvip | tinyint(1) | YES | | NULL | || passwd | char(32) | YES | | NULL | || regTime | datetime | YES | | NULL | || balance | decimal(10,2) | YES | | NULL | |+----------+---------------+------+-----+---------+-------+7 rows in set (0.0194 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 添加新的列ALTER TABLE 表名 ADD COLUMN 列名 列的数据类型; 比如我想新建一个last_login列 MySQL 192.168.31.238:3306 ssl Hachimi SQL ALTER TABLE UserData ADD COLUMN last_login DATETIME;Query OK, 0 rows affected (0.2408 sec)Records: 0 Duplicates: 0 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL DESC UserData;+------------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------+---------------+------+-----+---------+-------+| dickname | varchar(30) | YES | | NULL | || userid | int | YES | | NULL | || phone | varchar(11) | YES | | NULL | || isvip | tinyint(1) | YES | | NULL | || passwd | char(32) | YES | | NULL | || regTime | datetime | YES | | NULL | || balance | decimal(10,2) | YES | | NULL | || last_login | datetime | YES | | NULL | |+------------+---------------+------+-----+---------+-------+8 rows in set (0.0150 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 删除列ALTER TABLE 表名 DROP COLUMN 列名; 比如我想删掉刚刚创建的last_login列 MySQL 192.168.31.238:3306 ssl Hachimi SQL ALTER TABLE UserData DROP COLUMN last_login;Query OK, 0 rows affected (0.2320 sec)Records: 0 Duplicates: 0 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL DESC UserData;+----------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+---------------+------+-----+---------+-------+| dickname | varchar(30) | YES | | NULL | || userid | int | YES | | NULL | || phone | varchar(11) | YES | | NULL | || isvip | tinyint(1) | YES | | NULL | || passwd | char(32) | YES | | NULL | || regTime | datetime | YES | | NULL | || balance | decimal(10,2) | YES | | NULL | |+----------+---------------+------+-----+---------+-------+7 rows in set (0.0168 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 删除表使用DROP TABLE 表名即可 MySQL 192.168.31.238:3306 ssl Hachimi SQL SHOW TABLES;+-------------------+| Tables_in_Hachimi |+-------------------+| UserData |+-------------------+1 row in set (0.0167 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL DROP TABLE UserData;Query OK, 0 rows affected (0.1020 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL SHOW TABLES;Empty set (0.0730 sec) 数据的操作先把刚刚删掉的Hachimi表再创建回来，下面演示数据库四大金刚增删查改操作 INSERT-增(插)单条插入INSERT INTO user (列名) VALUES (数据); 比如我要往UserData里插入一条用户数据 MySQL 192.168.31.238:3306 ssl Hachimi SQL INSERT INTO UserData (username,userid,phone,isvip,passwd,regTime,balance) VALUES (哈基米,1,13988888888,0,12B2E5A579905F6FDE204ED28BA209B6,CURRENT_TIMESTAMP,16.5);Query OK, 1 row affected (0.0526 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+1 row in set (0.0161 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 可以看到UserData表里多了一个哈基米用户 可以不插入所有列的数据。如果不插入就会默认是NULL，如果有设置默认值的话就会是默认值 多条插入INSERT INTO user (列名) VALUES (数据),(数据); 比如我要往UserData里再插入三条用户数据 MySQL 192.168.31.238:3306 ssl Hachimi SQL INSERT INTO UserData (username,userid,phone,isvip,passwd,regTime,balance) VALUES - (哈基爸,1,15564521111,0,10617BC8A54FA085DC7F3E32E89EF7E9,2026-01-02 08:00:00,14.5), - (哈基爷,1,16512341234,0,12C544228857E7DB1A9872B5E37B5704,2026-01-02 09:00:00,12.5), - (哈基孙,1,18912341234,0,BBC7180B5D0FB714FD4CC0EEB480E10B,2026-01-02 09:00:00,12.5);Query OK, 3 rows affected (0.0507 sec)Records: 3 Duplicates: 0 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+ | username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 || 哈基爸 | 1 | 15564521111 | 0 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 || 哈基爷 | 1 | 16512341234 | 0 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 0 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+4 rows in set (0.0066 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 添加数据时使用默认值还记得上面的修改列的内容吗，可以使用DEFAULT指定默认值 先把isvip,regTime,balance,passwd这几列设置一个默认值 ALTER TABLE UserData MODIFY COLUMN isvip INT DEFAULT 0;ALTER TABLE UserData MODIFY COLUMN passwd CHAR(32) DEFAULT E10ADC3949BA59ABBE56E057F20F883E;ALTER TABLE UserData MODIFY COLUMN regTime DATETIME DEFAULT CURRENT_TIMESTAMP;ALTER TABLE UserData MODIFY COLUMN balance decimal(10,2) DEFAULT 0.0; 当然也可以合并成一条sql一次性修改 ALTER TABLE UserDataMODIFY COLUMN isvip INT DEFAULT 0,MODIFY COLUMN passwd CHAR(32) DEFAULT E10ADC3949BA59ABBE56E057F20F883E,MODIFY COLUMN regTime DATETIME DEFAULT CURRENT_TIMESTAMP,MODIFY COLUMN balance DECIMAL(10,2) DEFAULT 0.0; 执行后的效果就是这样 MySQL 192.168.31.238:3306 ssl Hachimi SQL desc UserData;+----------+---------------+------+-----+----------------------------------+-------------------+| Field | Type | Null | Key | Default | Extra |+----------+---------------+------+-----+----------------------------------+-------------------+| username | varchar(50) | YES | | NULL | || userid | int | YES | | NULL | || phone | varchar(11) | YES | | NULL | || isvip | int | YES | | 0 | || passwd | char(32) | YES | | E10ADC3949BA59ABBE56E057F20F883E | || regTime | datetime | YES | | CURRENT_TIMESTAMP | DEFAULT_GENERATED || balance | decimal(10,2) | YES | | 0.00 | |+----------+---------------+------+-----+----------------------------------+-------------------+7 rows in set (0.0095 sec) MySQL 192.168.31.238:3306 ssl Hachimi SQL 这时候再新增数据，只需指定username userid phone三个列的内容，其余没有指定的内容就会使用默认值 MySQL 192.168.31.238:3306 ssl Hachimi SQL INSERT INTO UserData (username,userid,phone) VALUES (哈基冯,2,13112345678);Query OK, 1 row affected (0.0322 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 || 哈基爸 | 1 | 15564521111 | 0 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 || 哈基爷 | 1 | 16512341234 | 0 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 0 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 || 哈基冯 | 2 | 13112345678 | 0 | E10ADC3949BA59ABBE56E057F20F883E | 2026-01-02 08:23:47 | 0.00 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+5 rows in set (0.0149 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL SELECT-查查询的SQL语句顺序要求如下 顺序 关键字 作用 1 SELECT 选哪些列 2 FROM 从哪个表 3 WHERE 过滤条件 4 ORDER BY 排序 5 LIMIT OFFSET 分页截取 查全部SELECT * FROM 表名; 比如我要查UserData下所有数据 MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 || 哈基爸 | 1 | 15564521111 | 0 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 || 哈基爷 | 1 | 16512341234 | 0 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 0 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 || 哈基冯 | 2 | 13112345678 | 0 | E10ADC3949BA59ABBE56E057F20F883E | 2026-01-02 08:23:47 | 0.00 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+5 rows in set (0.0172 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 查指定列SELECT 列名 FROM 表名; --查单个列SELECT 列名1,列名2 FROM 表名; --查多个列 比如我要查UserData下username和phone的数据 MySQL 192.168.31.238:3306 ssl Hachimi SQL select username,phone from UserData;+----------+-------------+| username | phone |+----------+-------------+| 哈基米 | 13988888888 || 哈基爸 | 15564521111 || 哈基爷 | 16512341234 || 哈基孙 | 18912341234 || 哈基冯 | 13112345678 |+----------+-------------+5 rows in set (0.0119 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 条件查询SELECT 字段 FROM 表名 WHERE 查询条件; 查询条件需要配合上面的Mysql的运算符来一起使用 现在数据表里都是哈基一家人，比如我想找到哈基冯的所有数据或者单独找到手机号数据 MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData where username like %冯;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基冯 | 2 | 13112345678 | 0 | E10ADC3949BA59ABBE56E057F20F883E | 2026-01-02 08:23:47 | 0.00 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+1 row in set (0.0170 sec) MySQL 192.168.31.238:3306 ssl Hachimi SQL select phone from UserData where username like %冯;+-------------+| phone |+-------------+| 13112345678 |+-------------+1 row in set (0.0189 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 如果使用LIKE，不加%或者_的话就是要求精确匹配 排序 + 分页SELECT * FROM 表名ORDER BY 列名 DESCLIMIT 要取多少条 OFFSET 跳过多少条; DESC是指从高到低，如果要换成从低到高就换成ASC（或者干脆不写，因为默认就是升序） 比如我要取哈基一家最富有的前二名 MySQL 192.168.31.238:3306 ssl Hachimi SQL SELECT * FROM UserData ORDER BY balance DESC LIMIT 2;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 || 哈基爸 | 1 | 15564521111 | 0 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+2 rows in set (0.0118 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 如果我要看第二页，就使用OFFSET MySQL 192.168.31.238:3306 ssl Hachimi SQL SELECT * FROM UserData ORDER BY balance DESC LIMIT 2 OFFSET 2;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基爷 | 1 | 16512341234 | 0 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 0 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+2 rows in set (0.0052 sec) 使用运算符增加查询条件，比如要求余额还得大于15 MySQL 192.168.31.238:3306 ssl Hachimi SQL SELECT * FROM UserData WHERE balance 15 ORDER BY balance DESC LIMIT 2 OFFSET 0;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+1 row in set (0.0120 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL UPDATE-改UPDATE 表名 SET 列名 = 数据 WHERE 条件; 全局更新如果不加WHERE的话就会修改表内所有的数据。比如现在我要给哈基一家全都开通VIP MySQL 192.168.31.238:3306 ssl Hachimi SQL update UserData set isvip = 1;Query OK, 5 rows affected (0.0311 sec)Rows matched: 5 Changed: 5 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 1 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 || 哈基爸 | 1 | 15564521111 | 1 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 || 哈基爷 | 1 | 16512341234 | 1 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 1 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 || 哈基冯 | 2 | 13112345678 | 1 | E10ADC3949BA59ABBE56E057F20F883E | 2026-01-02 08:23:47 | 0.00 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+5 rows in set (0.0248 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL 条件更新通过WHERE条件，来单独再关掉哈基米的VIP MySQL 192.168.31.238:3306 ssl Hachimi SQL update UserData set isvip = 0 where username like 哈基米;Query OK, 1 row affected (0.0387 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData; ;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基米 | 1 | 13988888888 | 0 | 12B2E5A579905F6FDE204ED28BA209B6 | 2026-01-02 08:01:58 | 16.50 || 哈基爸 | 1 | 15564521111 | 1 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 || 哈基爷 | 1 | 16512341234 | 1 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 1 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 || 哈基冯 | 2 | 13112345678 | 1 | E10ADC3949BA59ABBE56E057F20F883E | 2026-01-02 08:23:47 | 0.00 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+5 rows in set (0.0123 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL DELETE-删DELETE FROM 表名 WHERE 条件; 条件删除比如我要删掉哈基米的用户数据 MySQL 192.168.31.238:3306 ssl Hachimi SQL delete from UserData where username like 哈基米;Query OK, 1 row affected (0.1144 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData; ;+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| username | userid | phone | isvip | passwd | regTime | balance |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+| 哈基爸 | 1 | 15564521111 | 1 | 10617BC8A54FA085DC7F3E32E89EF7E9 | 2026-01-02 08:00:00 | 14.50 || 哈基爷 | 1 | 16512341234 | 1 | 12C544228857E7DB1A9872B5E37B5704 | 2026-01-02 09:00:00 | 12.50 || 哈基孙 | 1 | 18912341234 | 1 | BBC7180B5D0FB714FD4CC0EEB480E10B | 2026-01-02 09:00:00 | 12.50 || 哈基冯 | 2 | 13112345678 | 1 | E10ADC3949BA59ABBE56E057F20F883E | 2026-01-02 08:23:47 | 0.00 |+----------+--------+-------------+-------+----------------------------------+---------------------+---------+4 rows in set (0.0283 sec) 跑路了兄弟如果不加WHERE就是全表删除了 MySQL 192.168.31.238:3306 ssl Hachimi SQL delete from UserData;Query OK, 4 rows affected (0.0550 sec)MySQL 192.168.31.238:3306 ssl Hachimi SQL select * from UserData;Empty set (0.0215 sec) 作为sqlboy还需要知道的…1. 什么是主键 ？主键就像是每个人的身份证号。 唯一性：表里的每一行数据，主键值必须是独一无二的。 非空性：主键绝对不能为空（NOT NULL）。 作用：它是每一行数据的“唯一标识”，数据库通过主键精准定位某一行。 注意： 一个表只能有一个主键。 2. 怎么设置主键？通常在创建表（CREATE TABLE）的时候指定。最常见的方法是让它自动递增（AUTO_INCREMENT），这样你插入数据时就不用管它，数据库会自动帮你数数（1, 2, 3…）。 创建表时设置： CREATE TABLE Users ( userid INT PRIMARY KEY AUTO_INCREMENT, -- 设置userid为主键，且自动增长 username VARCHAR(50)); 如果表已经创建了，想给现有列加主键： ALTER TABLE UserData ADD PRIMARY KEY (userid); 3. 怎么配置列的内容不能重复？如果想让某列（比如手机号、邮箱）不重复，但不把它当成主键，就需要使用 UNIQUE（唯一约束）。 区别：主键一张表只能有一个，但 UNIQUE 约束可以给很多列都加上。 空值：UNIQUE 允许内容为空（NULL），但只要有内容，就必须唯一。 示例： CREATE TABLE UserData ( userid INT PRIMARY KEY AUTO_INCREMENT, phone VARCHAR(20) UNIQUE, -- 设置手机号不能重复 email VARCHAR(50) UNIQUE -- 设置邮箱也不能重复);","tags":["notebook","Mysql","Database"]},{"title":"关于我","path":"/about/index.html","content":"今年技能目标: 后端:golang(GinGorm) + docker + k8s + git + mysql(已完成) + redis + Elasticsearch 前端:TypeScript + React + Tailwind + Vite + uniapp 安卓:Kotlin 今年证书目标: TCP 我的Github主页 给我的新项目点点star: GitHub - fsquirtAutoglm-Android: 一款无需电脑，通过Shizuku来让Autoglm操作你的手机的程序 友链商务交流:guanxiaoyu@cloudyou.top"}]