
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 8.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>Golang攻略-其他语言迁移到Go - cloudyou</title>

  
    <meta name="description" content="点开我就当至少你会Python C++ C# Java任意一种了，所以示例代码为主，没有的话不要继续看因为会看不懂。所以安装我就不多说了，Windows去这里下安装包，linux用包管理器。看完本文你将速通Go的基本语法，变量声明，数组，循环，Switch，函数，结构体，Map，错误处理，接口&#x2F;鸭子类型，指针 先跑起来创建个新文件夹，然后用vscode打开，搭一下脚手架 1234go e">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang攻略-其他语言迁移到Go">
<meta property="og:url" content="https://www.cloudyou.top/2026/01/06/golang-start/">
<meta property="og:site_name" content="cloudyou">
<meta property="og:description" content="点开我就当至少你会Python C++ C# Java任意一种了，所以示例代码为主，没有的话不要继续看因为会看不懂。所以安装我就不多说了，Windows去这里下安装包，linux用包管理器。看完本文你将速通Go的基本语法，变量声明，数组，循环，Switch，函数，结构体，Map，错误处理，接口&#x2F;鸭子类型，指针 先跑起来创建个新文件夹，然后用vscode打开，搭一下脚手架 1234go e">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.cloudyou.top/images/%E5%A4%B4%E5%83%8F.jpg">
<meta property="article:published_time" content="2026-01-06T13:49:20.000Z">
<meta property="article:modified_time" content="2026-01-09T14:28:04.511Z">
<meta property="article:author" content="关小雨">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="notebook">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.cloudyou.top/images/%E5%A4%B4%E5%83%8F.jpg">
  
  
  
  <meta name="keywords" content="golang,notebook">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"关小雨","sameAs":[],"image":"/images/头像.jpg"},"dateCreated":"2026-01-06T21:49:20+08:00","dateModified":"2026-01-09T22:28:04+08:00","datePublished":"2026-01-06T21:49:20+08:00","description":"","headline":"Golang攻略-其他语言迁移到Go","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cloudyou.top/2026/01/06/golang-start/"},"publisher":{"@type":"Organization","name":"关小雨","sameAs":[],"image":"/images/头像.jpg","logo":{"@type":"ImageObject","url":"/images/头像.jpg"}},"url":"https://www.cloudyou.top/2026/01/06/golang-start/","keywords":"golang, notebook","thumbnailUrl":"/images/go.png","image":1}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/头像.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">cloudyou</div><div class="sub normal cap">rm -rf /past && touch future</div><div class="sub hover cap" style="opacity:0"> 在比特的洪流中盘桓此刻</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2026/01/06/golang-start/"><span class="title">Golang攻略-其他语言迁移到Go</span></a><a class="item title" href="/2026/01/04/mysql-higher/"><span class="title">Mysql攻略-进阶功能到更多</span></a><a class="item title" href="/2026/01/02/mysql-super/"><span class="title">Mysql攻略-高级查询到进阶功能</span></a><a class="item title" href="/2026/01/02/mysql-quick/"><span class="title">Mysql攻略-安装使用到基础的增删改查</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top"><img class="lazy bg" data-src="/images/go.png">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2026-01-06T13:49:20.000Z">2026-01-06</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2026-01-09T14:28:04.511Z">2026-01-09</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Golang攻略-其他语言迁移到Go</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>点开我就当至少你会Python C++ C# Java任意一种了，所以示例代码为主，<del>没有的话不要继续看因为会看不懂</del>。所以安装我就不多说了，Windows去<a target="_blank" rel="noopener" href="https://go.dev/dl/">这里</a>下安装包，linux用包管理器。看完本文你将速通Go的基本语法，变量声明，数组，循环，Switch，函数，结构体，Map，错误处理，接口&#x2F;鸭子类型，指针</p>
<h1 id="先跑起来"><a href="#先跑起来" class="headerlink" title="先跑起来"></a>先跑起来</h1><p>创建个新文件夹，然后用vscode打开，搭一下脚手架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go install golang.org/x/tools/gopls@latest</span><br><span class="line">go mod init go-starter</span><br></pre></td></tr></table></figure>

<h2 id="GO111MODULE？"><a href="#GO111MODULE？" class="headerlink" title="GO111MODULE？"></a>GO111MODULE？</h2><p><code>GO111MODULE=on</code>是开启 Go 的现代包管理模式，并且把这个设置全局保存</p>
<p>在 Go 1.11 版本（也就是变量名里 <code>111</code> 的由来）之前，Go 的包管理非常反人类，被称为 GOPATH 模式。</p>
<p>旧模式 (GOPATH)：</p>
<p>所有的代码项目，必须强制放在一个固定的文件夹里（比如 <code>D:\GoWorks\src</code>）。这就像 C# 强制要求把所有 Visual Studio 的项目都放在<code>C:\Windows\Microsoft.NET\Framework</code> 下面一样荒谬。没有版本控制的概念。<code>go get</code> 下来的库，作者升级了，项目可能就炸了。</p>
<p>新模式 (Go Modules)：</p>
<p>也就是 <code>GO111MODULE=on</code>。代码可以放在电脑的任何地方（桌面、D盘、E盘随便）。它使用 <code>go.mod</code> 文件来记录依赖版本（类似于 Python 的 <code>requirements.txt</code> 或 C# 的 <code>.csproj</code>&#x2F;<code>packages.config</code>）。</p>
<h2 id="项目-go-install和go-get？"><a href="#项目-go-install和go-get？" class="headerlink" title="项目? go install和go get？"></a>项目? <code>go install</code>和<code>go get</code>？</h2><p>如果不创建一个项目的话，vscode右下角会一直爆警告，而且代码补全可能会失效，因为它不知道包依赖关系。刚刚装的<code>gopls</code>就是go语言的IntelliSense引擎。项目也是使用<code>go get</code>安装第三方库要用的，类似于nodejs的<code>package.json</code></p>
<p><code>go install</code>会不会就是类似于python的<code>pip install</code>？其实不然</p>
<p><code>go install</code>是用来装 工具（可执行程序 .exe）的，<code>go get</code>是用来装库（依赖包） 的。</p>
<p>Python的<code>pip</code>是两个都可以装，比如我可以<code>pip install jupyter</code>，然后直接在cmd里使用<code>jupyter notebook</code>启动网页端程序，也可以使用<code>pip install requests</code>装包然后在别的.py里使用</p>
<p>go把它拆开来了</p>
<p>比如刚刚装的<code>gopls</code>，实际就是：先下载<code>gopls</code>的源代码，把它编译成exe后丢进<code>GOPATH</code>里给vscode用</p>
<p>现在的 <code>go get</code> 已经禁止安装可执行文件了，必须用 <code>go install</code>。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">作用</th>
<th align="left">产物</th>
<th align="left">类比 Python</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>go install</code></strong></td>
<td align="left">安装二进制工具</td>
<td align="left">生成 <code>.exe</code> 放到 bin 目录</td>
<td align="left"><code>pip install httpie</code> (为了用命令)</td>
</tr>
<tr>
<td align="left"><strong><code>go get</code></strong></td>
<td align="left">安装开发依赖库</td>
<td align="left">更新 <code>go.mod</code>，下载源码供 import</td>
<td align="left"><code>pip install requests</code> (为了写代码)</td>
</tr>
</tbody></table>
<h2 id="你好世界"><a href="#你好世界" class="headerlink" title="你好世界"></a>你好世界</h2><p>编程惯例写个hello world能提高运气</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hellooooo worlddddd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>go build *.go</code>生成二进制文件或者<code>go run *.go</code>直接运行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\go<span class="literal">-start</span>&gt; go build .\hello.go</span><br><span class="line"><span class="built_in">PS</span> D:\go<span class="literal">-start</span>&gt; .\hello.exe</span><br><span class="line">Hello, World!</span><br><span class="line"><span class="built_in">PS</span> D:\go<span class="literal">-start</span>&gt; go run .\hello.go  </span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p><code>package main</code> 是干嘛的？</p>
<p>Go 的编译器（<code>go build</code> 或 <code>go run</code>）需要知道代码的入口在哪里。</p>
<p>一个可执行程序必须有一个名为 <code>main</code> 的包，并且该包里必须包含一个 <code>main()</code> 函数。</p>
<p>如果没有 <code>package main</code>，Go 会把它当成一个库，就不会去找入口函数，也就跑不起来。</p>
<p>别的如果有编程基础都能看懂</p>
<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><h2 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hajimi <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> wochao <span class="type">int</span> = <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>变量会被初始化为该类型的零值，也可以在后面加上赋值</p>
<h2 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hajimi := <span class="string">&quot;&quot;</span></span><br><span class="line">    wochao := <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(hajimi, <span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    _ = wochao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>:=</code>关键字，不需要写类型，go会直接根据内容推导出变量数据类型</p>
<p>但是注意，这样声明变量只能在函数内部。而且golang有个特性，函数内部声明了的变量就必须要用，不然编译会报错。所以最后把<code>wochao</code>赋值给了下划线 <code>_</code> 占位符</p>
<h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设函数返回 (int, error)</span></span><br><span class="line">count, _ := getCount() <span class="comment">// 忽略掉第二个返回的 error</span></span><br></pre></td></tr></table></figure>

<p>如果调用一个返回多个值的函数，但只想用其中一个，可以用下划线 <code>_</code> 占位。</p>
<h2 id="一次声明多个变量"><a href="#一次声明多个变量" class="headerlink" title="一次声明多个变量"></a>一次声明多个变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y, z = <span class="literal">true</span>, <span class="string">&quot;two&quot;</span>, <span class="number">3</span> <span class="comment">// 不同类型</span></span><br><span class="line">    <span class="keyword">var</span> a, b, c <span class="type">string</span>           <span class="comment">// 相同类型</span></span><br><span class="line">    name, age := <span class="string">&quot;关小雨&quot;</span>, <span class="number">18</span>       <span class="comment">// 短变量声明</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(name, age)</span><br><span class="line">    fmt.Println(x, y, z)</span><br><span class="line">    c = a + b + c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过标准格式和短变量声明一次声明多个变量，变量可以是不同的数据类型</p>
<p>这样运行的输出是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关小雨 18</span><br><span class="line">true two 3</span><br></pre></td></tr></table></figure>

<h2 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h2><p>如果有很多很多变量，可以用括号包起来，通常用于全局变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name   <span class="type">string</span> = <span class="string">&quot;关小雨&quot;</span></span><br><span class="line">    age    <span class="type">int</span>    = <span class="number">18</span></span><br><span class="line">    sex    <span class="type">string</span> = <span class="string">&quot;女&quot;</span></span><br><span class="line">    height <span class="type">float32</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>array，顾名思义，数组，和C一样，长度固定的数组</p>
<h3 id="最经典"><a href="#最经典" class="headerlink" title="最经典"></a>最经典</h3><p>长度是类型的一部分，且长度固定。下面是最标准的写法，声明时指定长度和类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 5 的 int 数组，默认全是 0</span></span><br><span class="line"><span class="keyword">var</span> nums [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并直接初始化</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短变量声明</span></span><br><span class="line">names := [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒得数了"><a href="#懒得数了" class="headerlink" title="懒得数了"></a>懒得数了</h3><p>我懒得数长度了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br></pre></td></tr></table></figure>

<p>这样编译器会去数个数，长度还是5</p>
<h3 id="指定赋值"><a href="#指定赋值" class="headerlink" title="指定赋值"></a>指定赋值</h3><p>可以只给数组里某几个位置赋值，其他位置会自动补零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引 1 是 10，索引 3 是 30，长度为 5</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="comment">// 结果: [0, 10, 0, 30, 0]</span></span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>用法和别的编程语言一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2行3列</span></span><br><span class="line">matrix := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;</span><br><span class="line"> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(matrix[<span class="number">1</span>][<span class="number">2</span>]) <span class="comment">// 输出 6  </span></span><br></pre></td></tr></table></figure>

<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>OK上面关于数组的内容<del><strong>统统没有用</strong></del>，因为我们99%的时间都在用切片，而不是数组。切片是对数组的封装，它的长度可以根据需要动态增长。说人话就是动态数组</p>
<h3 id="创建动态数组"><a href="#创建动态数组" class="headerlink" title="创建动态数组"></a>创建动态数组</h3><p>和数组一样，就是不需要指定中括号里的数字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>make()</code>并指定预留的长度和初始的数据</p>
<p>上面第二行的意思就是s2有5个0在里面，但是给他预留了10个<code>int</code>的空间</p>
<p>但是切片是动态长度，预留空间何意味？</p>
<p>如果不预留，超出长度的时候，Go 发现没地方了 -&gt; 开辟新内存 -&gt; 搬家 -&gt; 再append -&gt;</p>
<p>又没地方了 -&gt; 再次开辟更大内存 -&gt; 再次搬家</p>
<p>频繁搬家（内存分配和数据复制）非常消耗性能，前 10 次添加数据，Go 发现还有空位，直接放进去就行，不需要搬家。等到第 11 个数据来了，包间满了，Go 才会进行一次大规模搬家（通常会把容量翻倍，比如换个 20 人的大包间）。</p>
<p>设定 <code>cap</code> (容量) 是为了 <strong>减少底层数组扩容的次数，提高程序运行速度</strong>。虽然不设也能跑，但设了跑得更快。</p>
<h3 id="往里面加东西"><a href="#往里面加东西" class="headerlink" title="往里面加东西"></a>往里面加东西</h3><p>通过append可以往动态数组里塞数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>)          <span class="comment">// 添加一个：[1 2 3]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)    <span class="comment">// 添加多个：[1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至可以把另一个切片直接倒进去（注意后面有三个点）</span></span><br><span class="line">another := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, another...) <span class="comment">// [1 2 3 4 5 6 7 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="动态数组的切片"><a href="#动态数组的切片" class="headerlink" title="动态数组的切片"></a>动态数组的切片</h3><p>和python的list切片类似，可以从一个现成的数组或动态数组中，截取出一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 截取索引 1 到 3 (左闭右开)</span></span><br><span class="line"><span class="comment">// 结果: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快捷写法</span></span><br><span class="line">s = arr[:<span class="number">3</span>] <span class="comment">// 从开头到索引 2</span></span><br><span class="line">s = arr[<span class="number">2</span>:] <span class="comment">// 从索引 2 到结尾</span></span><br></pre></td></tr></table></figure>

<p><del>（所以我要叫它动态数组，要不然我就要说是切片的切片）</del></p>
<h3 id="数组和动态数组的传递"><a href="#数组和动态数组的传递" class="headerlink" title="数组和动态数组的传递"></a>数组和动态数组的传递</h3><p>数组是值传递，会把值复制一份用于传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(a [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">999</span> <span class="comment">// 这里改的是副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    change(nums)</span><br><span class="line">    fmt.Println(nums[<span class="number">0</span>]) <span class="comment">// 依然是 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而切片是“引用”传递，实际上是传了一个包含指针的结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    update(nums)</span><br><span class="line">    fmt.Println(nums[<span class="number">0</span>]) <span class="comment">// 输出 888</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格来说，Go 只有值传递。切片本质上是一个只有 3 个字段的结构体 <code>Struct { ptr, len, cap }</code>。当传递切片时，是把这个小结构体复制（值传递）了一份。但因为里面那个 <code>ptr</code> 指针指向了同一个底层数组，所以修改数据会同步。</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="最经典-1"><a href="#最经典-1" class="headerlink" title="最经典"></a>最经典</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源·while"><a href="#源·while" class="headerlink" title="源·while"></a>源·while</h2><p>go里面没有<code>while</code>，但是可以直接把<code>for</code>循环当<code>while</code>用。</p>
<p>也是因为go没有<code>while</code>关键字，所以<code>while</code>在go里甚至可以定义成变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> while &lt; <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(while)</span><br><span class="line">    while++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果什么都不加，直接一个<code>for</code>起手那就是死循环了</p>
<h2 id="次跑循环"><a href="#次跑循环" class="headerlink" title="次跑循环"></a>次跑循环</h2><p>类似于python中的<code>for i in range(5)</code>，不过格式是这么写的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="精准定位"><a href="#精准定位" class="headerlink" title="精准定位"></a>精准定位</h2><p>类似于python的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="string">&quot;你好Go&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位置 <span class="subst">&#123;i&#125;</span> 的字符是 <span class="subst">&#123;char&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在go里面不需要借助额外的函数，直接这么写:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, char := <span class="keyword">range</span> <span class="string">&quot;你好Go&quot;</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;位置 %d 的字符是 %c\n&quot;</span>, i, char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我要遍历数组或者动态数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> nums</span><br></pre></td></tr></table></figure>

<p>就当go会展开为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    v := nums[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go的for循环语法糖:</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>for i := range s</code></td>
<td>只要索引</td>
</tr>
<tr>
<td><code>for _, v := range s</code></td>
<td>只要值</td>
</tr>
<tr>
<td><code>for range s</code></td>
<td>什么都不要，只循环次数</td>
</tr>
</tbody></table>
<h2 id="打个坐标"><a href="#打个坐标" class="headerlink" title="打个坐标"></a>打个坐标</h2><p>如果有嵌套循环，想在内层循环直接跳出最外层，可以使用标签。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i*j &gt; <span class="number">10</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> OuterLoop <span class="comment">// 直接跳出到最外层标签处</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>不要把<code>break OuterLoop</code>理解为<code>goto OuterLoop</code>，标签只是为了<strong>指明作用范围</strong>。当执行 <code>break OuterLoop</code> 时，编译器会找到 <code>OuterLoop</code> 标记的那层循环，并<strong>立即终止这整层循环</strong>。</p>
<p>如果是想跳过当前剩余逻辑，直接进入外层循环的下一次迭代，那就和其他语言一样使用<code>continue</code></p>
<h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><h2 id="最经典-2"><a href="#最经典-2" class="headerlink" title="最经典"></a>最经典</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 等于 1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 等于 2&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 等于 3&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 不等于 1, 2 或 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一case多值"><a href="#一case多值" class="headerlink" title="一case多值"></a>一case多值</h2><p>我也不知道是不是go的特性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 等于 1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 大于 2 小于 10&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 大于 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以这么写，如果<code>switch</code>后面不加变量名，就类似于<code>if-else</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x == <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 等于 1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x &gt; <span class="number">2</span> &amp;&amp; x &lt; <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 大于 2 小于 10&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 大于 10&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="大炮穿箱"><a href="#大炮穿箱" class="headerlink" title="大炮穿箱"></a>大炮穿箱</h2><p>可以使用<code>fallthrough</code>来执行完当前 <code>case</code> 后继续执行下一个 <code>case</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x == <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 等于 1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x &gt; <span class="number">2</span> &amp;&amp; x &lt; <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 大于 2 小于 10&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x 大于 10&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在<code>case x &gt; 2 &amp;&amp; x &lt; 10:</code>增加了<code>fallthrough</code>，所以下一个<code>default case</code>也被执行了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x 大于 2 小于 10</span><br><span class="line">x 大于 10</span><br></pre></td></tr></table></figure>

<h2 id="顺手的事"><a href="#顺手的事" class="headerlink" title="顺手的事"></a>顺手的事</h2><p>可以在 <code>switch</code> 后面定义一个只在 <code>switch</code> 块内有效的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> grade := <span class="string">&quot;B&quot;</span>; grade &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;我超 bin&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;铸币吧&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="最经典-3"><a href="#最经典-3" class="headerlink" title="最经典"></a>最经典</h2><p>Go 的参数名在前，类型在后。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单参数，单返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同类型的参数可以简写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b, c <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多返回值 上面说过的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;除数不能为0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>味大无需多盐，有其他编程基础的都能看懂</p>
<h2 id="指定返回"><a href="#指定返回" class="headerlink" title="指定返回"></a>指定返回</h2><p>在函数头定义返回变量名，函数体里赋值，最后只用写个return就能返回指定变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRect</span><span class="params">(width, height <span class="type">int</span>)</span></span> (area, perimeter <span class="type">int</span>) &#123;</span><br><span class="line">    area = width * height</span><br><span class="line">    perimeter = (width + height) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 自动返回 area 和 perimeter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>用 <code>...</code> 表示可以传入任意数量的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>没有名字的函数，通常用于临时逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义并立即执行</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">&quot;Hello Go&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法函数"><a href="#方法函数" class="headerlink" title="方法函数"></a>方法函数</h2><p>Go没有类，但可以给结构体绑定函数。这个马上讲结构体会再提这里不展开</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (u User) 是接收者，表示这个函数属于 User</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> Greet() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, I am&quot;</span>, u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go 没有 <code>class</code>（类），结构体就是 Go 里的“类”。</p>
<p>它不仅能存数据，还能绑定方法，甚至通过“组合”来实现类似继承的功能。</p>
<h2 id="创建结构体"><a href="#创建结构体" class="headerlink" title="创建结构体"></a>创建结构体</h2><p>使用 <code>type</code> 和 <code>struct</code> 关键字。用法和别的编程语言类似</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	sex  <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//键值对初始化</span></span><br><span class="line">	u1 := user&#123;name: <span class="string">&quot;关小雨&quot;</span>, sex: <span class="string">&quot;female&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	fmt.Println(u1.name, u1.sex, u1.age)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//按顺序初始化</span></span><br><span class="line">	u2 := user&#123;<span class="string">&quot;云悠悠&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">	fmt.Println(u2.name, u2.sex, u2.age)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//什么都不填，全是零值</span></span><br><span class="line">	u3 := user&#123;&#125;</span><br><span class="line">	fmt.Println(u3.name, u3.sex, u3.age)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//部分初始化，其他为零值</span></span><br><span class="line">	u4 := user&#123;name: <span class="string">&quot;晴雅&quot;</span>&#125;</span><br><span class="line">	fmt.Println(u4.name, u4.sex, u4.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的输出就是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关小雨 female 18</span><br><span class="line">云悠悠 female 20</span><br><span class="line">  0</span><br><span class="line">晴雅  0</span><br></pre></td></tr></table></figure>

<h2 id="给结构体加函数"><a href="#给结构体加函数" class="headerlink" title="给结构体加函数"></a>给结构体加函数</h2><p>就是上文提到的方法函数(Method)，  Go 的方法定义和 C++ 不一样，它不写在结构体里面，而是写在外面，通过接收者 (Receiver)绑定到结构体上。</p>
<p>格式是这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数) 返回值 &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>接收者有两种，值接收者或者指针接收者</p>
<p>(u user)：值接收者。相当于把结构体<strong>复制</strong>了一份传进来。改了它，<strong>原来的数据不会变</strong>。</p>
<p>(u *user)：指针接收者，传的是内存地址。改了他原来的数据就变了</p>
<p>还是那个user结构体，给他分别用值接收者和指针接收者加上两个函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	sex  <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> sayHello() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;你好，我是 %s\n&quot;</span>, u.name)</span><br><span class="line">	<span class="comment">//尝试增加年龄</span></span><br><span class="line">	u.age++</span><br><span class="line">	fmt.Printf(<span class="string">&quot;在 sayHello 方法中，%s 的年龄是 %d\n&quot;</span>, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> haveBirthday() &#123;</span><br><span class="line">	u.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := user&#123;name: <span class="string">&quot;关小雨&quot;</span>, sex: <span class="string">&quot;female&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	u1.sayHello()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 现在是 %d 岁\n&quot;</span>, u1.name, u1.age)</span><br><span class="line"></span><br><span class="line">	u1.haveBirthday()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 现在是 %d 岁\n&quot;</span>, u1.name, u1.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的输出结果是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你好，我是 关小雨</span><br><span class="line">在 sayHello 方法中，关小雨 的年龄是 19</span><br><span class="line">关小雨 现在是 18 岁</span><br><span class="line">关小雨 现在是 19 岁</span><br></pre></td></tr></table></figure>

<h2 id="嵌套-组合"><a href="#嵌套-组合" class="headerlink" title="嵌套&#x2F;组合"></a>嵌套&#x2F;组合</h2><p>既然没有继承，怎么复用代码？go提倡 “组合优于继承”。可以把一个结构体塞进另一个结构体里，这叫匿名嵌入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> Eat() &#123;</span><br><span class="line">	fmt.Println(a.Type, <span class="string">&quot;正在吃东西...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Animal <span class="comment">// 并没有给字段起名字，直接写类型 -&gt; 这就是嵌入</span></span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := Dog&#123;</span><br><span class="line">		Name:   <span class="string">&quot;旺财&quot;</span>,</span><br><span class="line">		Animal: Animal&#123;Type: <span class="string">&quot;犬科&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d.Eat()                                    <span class="comment">//Dog 也拥有了 Animal 的方法</span></span><br><span class="line">	fmt.Println(d.Name, d.Type, d.Animal.Type) <span class="comment">//可以直接访问，也可以通过嵌入类型访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的输出结果是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">犬科 正在吃东西...</span><br><span class="line">旺财 犬科 犬科</span><br></pre></td></tr></table></figure>

<p><code>Dog</code> 并没有成为 <code>Animal</code> 的子类，它只是包含了一个 <code>Animal</code>。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>go语言的 <code>map</code> 就是哈希表，它是<strong>无序</strong>（每次遍历 Map 的顺序可能都不一样，Go 故意引入了随机性）的键值对集合。说人话就是python的<code>dict</code>和java的<code>hashmap</code></p>
<h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><p>声明 <code>map</code> 后，如果不用 <code>make</code> 初始化，它就是 <code>nil</code>，直接赋值会报错 panic</p>
<p>可以这样用<code>make</code>创建:<code>make(map[Key类型]Value类型)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) </span><br><span class="line">age[<span class="string">&quot;关小雨&quot;</span>] = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>也可以通过字面量初始化，声明的时候赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;关小雨&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;云悠悠&quot;</span>: <span class="number">20</span>, <span class="comment">// 最后一个逗号不能少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>无需多盐，字面意思</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增 &amp; 改</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;关小雨&quot;</span> <span class="comment">// 新增</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;云悠悠&quot;</span> <span class="comment">// 修改，覆盖旧值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">name := m[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">fmt.Println(name) <span class="comment">// 云悠悠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;name&quot;</span>) <span class="comment">// 删除键 &quot;name&quot;</span></span><br><span class="line"><span class="comment">// 如果删除一个不存在的键，Go 不会报错，什么都不发生</span></span><br></pre></td></tr></table></figure>

<h2 id="查不到啊"><a href="#查不到啊" class="headerlink" title="查不到啊"></a>查不到啊</h2><p>这是 <code>map</code> 独特的特性。去拿一个不存在的 Key 时，不会报错，而是返回该类型的零值（比如 int 返回 0，string 返回 “”）。<br>但这有个坑：不知道返回的 <code>0</code> 是因为它真的存了 <code>0</code>，还是因为根本没这个 Key。</p>
<p>解决方案：双返回值判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	age, ok := ages[<span class="string">&quot;关小雨&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;关小雨的分数是&quot;</span>, age)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ok</code> 是一个布尔值，<code>true</code> 表示存在，<code>false</code> 表示不存在。</p>
<h2 id="Key能用的类型？"><a href="#Key能用的类型？" class="headerlink" title="Key能用的类型？"></a>Key能用的类型？</h2><p>只要能用 <code>==</code> 比较的类型，都能当 Key。</p>
<p>可以：<code>bool</code>, <code>int</code>, <code>float</code>, <code>string</code>, <code>指针</code>, <code>channel</code>, <code>接口</code></p>
<p>不可以：动态数组, <code>map</code>, 函数</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>众所<strong>不</strong>周知，Go 语言<strong>没有</strong> <code>try-catch-finally</code> 这种异常处理机制。</p>
<p>Go 的设计哲学是：错误也是一种值。它不希望把错误“抛出”到一个不可预知的地方，而是希望原地处理或者显式地传递它。</p>
<p>在继续错误处理之前，得知道这么一个go的关键字:<code>nil</code></p>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p><code>nil</code> 是 go 语言中某些特定类型的<strong>默认零值</strong>。可以把它类比为其他语言中的 <code>null</code> 或 <code>None</code><br>在 Go 中，这些类型的“空值”都是 <code>nil</code>：接口，指针 ，切片，映射，通道和函数。</p>
<p>但是go的基本类型不能是nil而是默认值：</p>
<p><code>int</code> 的零值是 <code>0</code>。</p>
<p><code>string</code> 的零值是 <code>&quot;&quot;</code>（空字符串），不是 <code>nil</code>。</p>
<p><code>bool</code> 的零值是 <code>false</code>。</p>
<p>这样就杜绝了像 C 语言中“这到底是数字 0 还是空指针”的二义性。</p>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>让函数在返回结果的同时，多返回一个 <code>error</code> 类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    chushi := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> chushi &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;出事了&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res, err := doSomething()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 原地处理错误</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;报错:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没报错才继续</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;结果是:&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果返回的<code>error</code>不是<code>nil</code>，那就出大事了</p>
<h2 id="添加信息"><a href="#添加信息" class="headerlink" title="添加信息"></a>添加信息</h2><p>给底层的错误加点描述，再往上传，可以使用 <code>%w</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openConfig</span><span class="params">(filepath <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    _, err := os.Open(filepath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 %w 包装原始错误</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;读取配置文件失败: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := openConfig(<span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;出事了&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的输出就是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">出事了 读取配置文件失败: open config.yaml: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<h2 id="扣1复活"><a href="#扣1复活" class="headerlink" title="扣1复活"></a>扣1复活</h2><p>Go 虽然没有 <code>try-catch</code>，但有 <code>panic-recover</code> 机制。这不是用来处理普通业务错误的，而是用来处理毁灭性错误（比如数组越界、空指针、数据库连接不上）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;1111 复活成功并且捕捉到了崩溃:&quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;准备开始搞破坏...&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;坠机了&quot;</span>) <span class="comment">// 相当于 throw</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    protect()</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续运行...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>defer</code>这个关键字的意思是:它后面的函数在当前函数退出前的最后一刻，一定会执行。哪怕函数崩溃了，<code>defer</code> 里的内容也会被执行。</p>
<p><code>recover</code>是用来”复活”程序的，只能写在defer里。用于获取到出的问题。<code>recover</code> 不仅能捕获手动写的 <code>panic</code>，还能捕获go运行时触发的“运行时错误”（Runtime Error）。</p>
<p><code>panic</code>是用来手动触发一个错误的函数</p>
<p>这样的执行结果是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">准备开始搞破坏...</span><br><span class="line">1111 复活成功并且捕捉到了崩溃: 坠机了</span><br><span class="line">程序继续运行...</span><br></pre></td></tr></table></figure>

<h2 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h2><p>在 Go 中，任何实现了<code>Error() string</code>方法的类型都可以是一个错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;错误码:%d, 消息:%s&quot;</span>, e.Code, e.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAPI</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;Code: <span class="number">404</span>, Message: <span class="string">&quot;找不到了&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := getAPI()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;API调用失败:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个后文讲鸭子类型的时候会再翻出来解析</p>
<h1 id="接口-鸭子类型"><a href="#接口-鸭子类型" class="headerlink" title="接口&#x2F;鸭子类型"></a>接口&#x2F;鸭子类型</h1><p>如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。</p>
<p>在 Go 里：只要一个类型实现了接口要求的所有方法，它就自动属于这个接口，不需要显式写 <code>implements</code>。</p>
<h2 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h2><p>先这样定义一个鸭叫接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Quack <span class="keyword">interface</span>&#123; Quack() &#125;</span><br></pre></td></tr></table></figure>

<p>但是不止鸭子能叫，人也能学鸭子叫。所以再定义人和鸭的结构体并实现<code>Quack</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> duck <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d duck)</span></span> Quack() &#123; fmt.Println(d.name, <span class="string">&quot;嘎嘎嘎&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> Quack() &#123; fmt.Println(p.name, <span class="string">&quot;学鸭子叫：嘎嘎嘎&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>现在再来创建一个用于调用鸭叫接口的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeQuack</span><span class="params">(q Quack)</span></span> &#123; q.Quack() &#125;</span><br></pre></td></tr></table></figure>

<p>person和duck都可以调用这个鸭叫接口函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := duck&#123;name: <span class="string">&quot;唐老鸭&quot;</span>&#125;</span><br><span class="line">	p1 := person&#123;name: <span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	makeQuack(d1)</span><br><span class="line">	makeQuack(p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">唐老鸭 嘎嘎嘎</span><br><span class="line">张三 学鸭子叫：嘎嘎嘎</span><br></pre></td></tr></table></figure>

<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>go中有一个特殊的接口:<code>any</code>，没有定义任何方法。既然没有任何要求，那就意味着：任何类型都实现了空接口。它可以装万物</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> duck <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i any = <span class="number">10</span> <span class="comment">// 可以装 int</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line"></span><br><span class="line">	i = <span class="string">&quot;Hello&quot;</span> <span class="comment">// 可以装 string</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line"></span><br><span class="line">	i = duck&#123;name: <span class="string">&quot;Daffy&quot;</span>&#125; <span class="comment">// 可以装 duck 结构体</span></span><br><span class="line">	fmt.Println(i.(duck).name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的输出结果是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">Hello</span><br><span class="line">Daffy</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go 的指针在语法上和 C&#x2F;C++ 非常像，但在逻辑上被“阉割”，为了安全和简单。</p>
<p>没有指针运算，没有复杂的内存管理，没有 <code>-&gt;</code> 箭头符号</p>
<h2 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h2><p>和C&#x2F;C++一样。<code>&amp;</code> (取地址)，获取变量的内存地址。<code>*</code> (解引用)，获取指针指向的值，或者定义指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	ptr := &amp;a</span><br><span class="line"></span><br><span class="line">	fmt.Println(ptr)  <span class="comment">// 0xc00000a0c8 内存地址</span></span><br><span class="line">	fmt.Println(*ptr) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">	*ptr = <span class="number">20</span></span><br><span class="line">	fmt.Println(a)    <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体指针的“语法糖”"><a href="#结构体指针的“语法糖”" class="headerlink" title="结构体指针的“语法糖”"></a>结构体指针的“语法糖”</h2><p>在 C++ 中，访问指针对象的字段要用箭头 <code>p-&gt;age</code>。在 Go 中，统一都用点 <code>.</code>。编译器会分辨是值还是指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;Name: <span class="string">&quot;关小雨&quot;</span>, Age: <span class="number">18</span>&#125;</span><br><span class="line">	ptr := &amp;u</span><br><span class="line">	ptr.Name = <span class="string">&quot;云悠悠&quot;</span> <span class="comment">// 编译器自动识别 ptr 是指针，自动解引用</span></span><br><span class="line">	fmt.Println(u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="需要修改外部变量"><a href="#需要修改外部变量" class="headerlink" title="需要修改外部变量"></a>需要修改外部变量</h3><p>go函数默认是值传递（拷贝）。如果想在函数里修改外面的变量，必须传指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收指针类型 *int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*n = <span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">10</span></span><br><span class="line">	change(&amp;x)     <span class="comment">// 传地址进去</span></span><br><span class="line">	fmt.Println(x) <span class="comment">// 999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免大对象拷贝"><a href="#避免大对象拷贝" class="headerlink" title="避免大对象拷贝"></a>避免大对象拷贝</h3><p>如果结构体很大（比如有 100 个字段），传值会发生一次巨大的内存拷贝。传指针只需要拷贝 8 个字节（64位系统），速度快很多。</p>
<h2 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">C++ 指针</th>
<th align="left">Go 指针</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义符号</strong></td>
<td align="left"><code>*</code></td>
<td align="left"><code>*</code></td>
</tr>
<tr>
<td align="left"><strong>取址符号</strong></td>
<td align="left"><code>&amp;</code></td>
<td align="left"><code>&amp;</code></td>
</tr>
<tr>
<td align="left"><strong>成员访问</strong></td>
<td align="left"><code>-&gt;</code> (指针), <code>.</code> (对象)</td>
<td align="left"><strong>统一用 <code>.</code></strong></td>
</tr>
<tr>
<td align="left"><strong>指针运算</strong></td>
<td align="left">支持 (<code>p++</code>, <code>p+1</code>)</td>
<td align="left"><strong>不支持</strong> (报错)</td>
</tr>
<tr>
<td align="left"><strong>野指针&#x2F;释放</strong></td>
<td align="left">需要手动 <code>delete</code></td>
<td align="left"><strong>GC 自动回收</strong>，不用管</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">危险 (易越界&#x2F;内存泄漏)</td>
<td align="left">相对安全</td>
</tr>
</tbody></table>
<h1 id="public-private"><a href="#public-private" class="headerlink" title="public?private?"></a>public?private?</h1><p>虽然我觉得这么做有点逆天但是，在 Go 中，首字母大写类似于Public，首字母小写类似于Private。不仅仅是变量名，还包括函数名、结构体名、结构体内部的字段名</p>
<p>为什么说类似，因为这个public和private都指的是能不能<strong>跨包</strong>访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> </span><br><span class="line">	age  <span class="type">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;name: <span class="string">&quot;关小雨&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	data, _ := json.Marshal(u)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样运行，输出是空的，json.Marshal 是 json 包里的函数，它是“外人”，它看不到 User 里没导出的 name 和 age。</p>
<p>但是如果把结构体变量名首字母都改成大写，就正常了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;Name: <span class="string">&quot;关小雨&quot;</span>, Age: <span class="number">18</span>&#125;</span><br><span class="line">	data, _ := json.Marshal(u)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行正常输出</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;关小雨&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>




<h1 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations"></a>Congratulations</h1><p>恭喜，看完本文你已经了解了其他编程语言到golang的迁移</p>
<p>你可能在找 <code>Goroutine</code> <code>Channel</code>？Go 最强的并发特性留到下一篇专门讲。</p>
</article>


<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2026/01/04/mysql-higher/">Mysql攻略-进阶功能到更多</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">关小雨</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br><span class="jinrishici-sentence"></span></p>
<script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%88%E8%B7%91%E8%B5%B7%E6%9D%A5"><span class="toc-text">先跑起来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GO111MODULE%EF%BC%9F"><span class="toc-text">GO111MODULE？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE-go-install%E5%92%8Cgo-get%EF%BC%9F"><span class="toc-text">项目? go install和go get？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C"><span class="toc-text">你好世界</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="toc-text">标准格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">短变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="toc-text">匿名变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-text">一次声明多个变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">批量声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%8F%E5%85%B8"><span class="toc-text">最经典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E5%BE%97%E6%95%B0%E4%BA%86"><span class="toc-text">懒得数了</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%B5%8B%E5%80%BC"><span class="toc-text">指定赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice"><span class="toc-text">Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">创建动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%80%E9%87%8C%E9%9D%A2%E5%8A%A0%E4%B8%9C%E8%A5%BF"><span class="toc-text">往里面加东西</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87"><span class="toc-text">动态数组的切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">数组和动态数组的传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%8F%E5%85%B8-1"><span class="toc-text">最经典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%C2%B7while"><span class="toc-text">源·while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A1%E8%B7%91%E5%BE%AA%E7%8E%AF"><span class="toc-text">次跑循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E5%87%86%E5%AE%9A%E4%BD%8D"><span class="toc-text">精准定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E4%B8%AA%E5%9D%90%E6%A0%87"><span class="toc-text">打个坐标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Switch"><span class="toc-text">Switch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%8F%E5%85%B8-2"><span class="toc-text">最经典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80case%E5%A4%9A%E5%80%BC"><span class="toc-text">一case多值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%82%AE%E7%A9%BF%E7%AE%B1"><span class="toc-text">大炮穿箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E6%89%8B%E7%9A%84%E4%BA%8B"><span class="toc-text">顺手的事</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%8F%E5%85%B8-3"><span class="toc-text">最经典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E"><span class="toc-text">指定返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-text">变长参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-text">方法函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">创建结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%E5%8A%A0%E5%87%BD%E6%95%B0"><span class="toc-text">给结构体加函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-%E7%BB%84%E5%90%88"><span class="toc-text">嵌套&#x2F;组合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">声明与初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">增删改查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E4%B8%8D%E5%88%B0%E5%95%8A"><span class="toc-text">查不到啊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key%E8%83%BD%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">Key能用的类型？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nil"><span class="toc-text">nil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">多返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-text">添加信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A31%E5%A4%8D%E6%B4%BB"><span class="toc-text">扣1复活</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89error"><span class="toc-text">自定义error</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-text">接口&#x2F;鸭子类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">创建和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-text">空接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88"><span class="toc-text">使用指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%84%E2%80%9C%E8%AF%AD%E6%B3%95%E7%B3%96%E2%80%9D"><span class="toc-text">结构体指针的“语法糖”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">需要修改外部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-text">避免大对象拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%80%8C%E8%A8%80%E4%B9%8B"><span class="toc-text">总而言之</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#public-private"><span class="toc-text">public?private?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Congratulations"><span class="toc-text">Congratulations</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":[],"codeblock":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
